{"meta":{"title":"Hanson|개발자","subtitle":"승한 개발 블로그","description":"알고리즘 문제, 수학, 최적화 문제에 흥미를 가지며 금융, 분석 개발자로 나아가는 블로그입니다.","author":"son seung Han","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-02-10T11:29:50.000Z","updated":"2019-03-14T07:04:29.960Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Introduce 온라인 이력서 끝날 때까지는 끝난 게 아니다.꾸준한 것이 최고라고 생각하는 개발자 손승한입니다.알고리즘 , 수학, 최적화 문제에 흥미를 가지고 금융 및 분석 개발자로 나아가고 있습니다.더불어 새로운 사람들과 어울리는 것을 좋아하며, 사람들과 다양한 주제로 토론하는 것을 좋아합니다. Language C, C++, Python, Java, Javascript Skills C / C++ / Python / Java / Javascript / jQuery MySQL / Oracle / MSSQL algorithm problem solving AWS(EC2, RDS, S3) / NCloud(server, cloud DB) UbuntuOS / CentOS / macOS Git / Github / SVN R / dataAnalysis PyCham / VSCode / Sourcetree / TortoiseSVN Slack / Trello / githubBlog Stock investment REST API Learning RESTful API R / dataAnalysis OOP(SOLID) / TDD / DDD / Refactoring / Clean Code / Design pattern NOSQL -&gt; Redis MSA Work ExperienceSummary 2018.08 ~ 2019.02 / Intern at Mobile C&amp;C(Operation Team)What did I do? Development BIZMOB(spring기반), Mybatis SVN Operation(troubleshooting) Side Project [python] 키움 api사용한 전종목 일봉데이터 저장 [python] 거래내역을 통한 MDD 평균, 횟수, 평균 이상의 MDD 발생 시기에 손실확정종목 추적 API 만들기 수상 및 활동 수상 및 활동 기간 “제4회 K해커톤 앱개발챌린지(사)앱센터 - 우수상” 2016.10 “에너지 ICT 분야 소프트웨어 경진대회(주)한전KDN - 우수상” 2016.12 “한국지능시스템학회 춘계학술대회우수논문상” 2017.4 목포대학교 멋쟁이사자처럼 동아리 개설 및 운영초대 동아리 회장 2017.1 - 2017.12 링크github - repositoriesgithub - 기술블로그tistory - 티스토리블로그"}],"posts":[{"title":"google-CodeJam-2019-참가자격획득","slug":"Blog-20190407-google-CodeJam-2019-참가자격획득","date":"2019-04-07T08:18:09.000Z","updated":"2019-04-07T08:59:05.843Z","comments":true,"path":"2019/04/07/Blog-20190407-google-CodeJam-2019-참가자격획득/","link":"","permalink":"http://yoursite.com/2019/04/07/Blog-20190407-google-CodeJam-2019-참가자격획득/","excerpt":"","text":"정말 오랫만에 알고리즘 문제를 풀었습니다. 오픈톡방에서 구글코드잼 대회 시작 했다는 말을 듣고 4문제중 3문제 도전해 2문제 해결해서 참가자격을 얻을 수 있었습니다. 1번 문제를 간단히 설명하면,4가 포함된 정수가 주어지면 리턴값으로 2개의 정수를 리턴해야합니다.리턴하는 정수의 규칙은 리턴하는 2개의수를 더했을 때 입력받은 정수가 되야합니다.하지만 리턴하는 2개의 정수에는 자연수 “4” 가 포함되어 있으면 안됩니다. 해결은 제한범위 전체탐색으로 했습니다.input값의 정수에 4가 있는 위치중에서 가장 큰 자릿수 n을 구해 10의 n제곱 된 정수부터빼서 전체 탐색을 하였습니다. 2번 문제는 1번보다 쉬웠습니다.저는 문제를 읽는 것보다 인풋과 리턴값에 집중해 문제를 이해하는데,2번 문제같은 경우에는 문제를 잘 읽기만 한다면 과장해서 1분안에 코딩 할 수 있습니다. 해결은 인풋값의 스트링이 ‘E’, ‘S’로 만 이뤄져 있는데이 string을 E -&gt; S, S -&gt; E 로 변경해서 만든 문자열을 리턴하면 됩니다. 3번 같은 경우인풋값의 소수곱들을 분해하기 위해서 10000 이하의 소수를 모두 구해둔 뒤소수 곱에서 1번째, 2번째 소수를 구합니다.그리고 반목문을 활용해 3번째 부터 마지막 소수까지 분해합니다.그리고 해당 소수 배열을 복사한뒤, 복사한 소수 배열을 정렬 하고 중복값을 제거하면26개 알파벳에 해당하는 N이하의 선택된 소수 26개를 파악 할 수 있습니다.이것을 c++의 map 자료구조에 입력 후 정렬하지 않은 소수 배열에 대입하여리턴값을 생성합니다. 3번이 런타임에러를 맛보는 유저가 많았습니다.아마도 ABABABAB 와 같은 초기 문자열이 발생했을 때 겪을 수 있을 것 같습니다.그리고 유클리드 알고리즘을 사용한다면 좀 더 빠른 속도의 풀이를 만들수 있을 겁니다.3번의 히든 스테이지를 풀려면 C++보다는 파이썬으로 빅넘버 라이브러리를 사용해서 풀어야 할 것입니다.","categories":[{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/categories/Blog/"}],"tags":[]},{"title":"REST ful 한 API","slug":"Blog-20190319-REST-ful-API","date":"2019-03-19T07:24:35.000Z","updated":"2019-03-24T10:41:43.074Z","comments":true,"path":"2019/03/19/Blog-20190319-REST-ful-API/","link":"","permalink":"http://yoursite.com/2019/03/19/Blog-20190319-REST-ful-API/","excerpt":"","text":"REST API 제대로 알고 사용하기목차 1. REST API의 탄생 2. REST 구성 3. REST 의 특징 4. REST API 디자인 가이드 5. HTTP 응답 상태 코드 1. REST API의 탄생REST는 Representational State Transfer라는 용어의 약자로서 2000년도에 로이 필딩 (Roy Fielding)의 박사학위 논문에서 최초로 소개되었습니다. 로이 필딩은 HTTP의 주요 저자 중 한 사람으로 그 당시 웹(HTTP) 설계의 우수성에 비해 제대로 사용되어지지 못하는 모습에 안타까워하며 웹의 장점을 최대한 활용할 수 있는 아키텍처로써 REST를 발표했다고 합니다. 2. REST 구성쉽게 말해 REST API는 다음의 구성으로 이루어져있습니다. 자세한 내용은 밑에서 설명하도록 하겠습니다. 자원(RESOURCE) - URI 행위(Verb) - HTTP METHOD 표현(Representations) 3. REST 의 특징1) Uniform (유니폼 인터페이스)Uniform Interface는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다. 2) Stateless (무상태성)REST는 무상태성 성격을 갖습니다. 다시 말해 작업을 위한 상태정보를 따로 저장하고 관리하지 않습니다. 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 됩니다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다. 3) Cacheable (캐시 가능)REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다. 따라서 HTTP가 가진 캐싱 기능이 적용 가능합니다. HTTP 프로토콜 표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하면 캐싱 구현이 가능합니다. 4) Self-descriptiveness (자체 표현 구조)REST의 또 다른 큰 특징 중 하나는 REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어 있다는 것입니다. 5) Client - Server 구조REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다. 6) 계층형 구조REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다. 4. REST API 디자인 가이드 REST API 설계 시 가장 중요한 항목은 다음의 2가지로 요약할 수 있습니다. 첫 번째, URI는 정보의 자원을 표현해야 한다.두 번째, 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다. 다른 것은 다 잊어도 위 내용은 꼭 기억하시길 바랍니다. 4-1. REST API 중심 규칙 1) URI는 정보의 자원을 표현해야 한다.(리소스명은 동사보다는 명사를 사용)1GET /members/delete/1 위와 같은 방식은 REST를 제대로 적용하지 않은 URI입니다. URI는 자원을 표현하는데 중점을 두어야 합니다. delete와 같은 행위에 대한 표현이 들어가서는 안됩니다. 2) 자원에 대한 행위는 HTTP Method(GET,POST,PUT,DELETE)로 표현위의 잘못 된 URI를 HTTP Method를 통해 수정해 보면1DELETE /members/1 으로 수정할 수 있겠습니다.회원정보를 가져올 때는 GET, 회원 추가 시의 행위를 표현하고자 할 때는 POST METHOD를 사용하여 표현합니다. 회원정보를 가져오는 URI12GET /members/show/1 (X)GET /members/1 (O) 회원을 추가할 때12GET /members/insert/2 (X) - GET 메서드는 리소스 생성에 맞지 않습니다. POST /members/2 (O) [참고]HTTP METHOD의 알맞은 역할POST, GET, PUT, DELETE 이 4가지의 Method를 가지고 CRUD를 할 수 있습니다. METHOD 역할 POST POST를 통해 해당 URI를 요청하면 리소스를 생성합니다. GET GET를 통해 해당 리소스를 조회합니다. 리소스를 조회하고 해당 도큐먼트에 대한 자세한 정보를 가져온다. PUT PUT를 통해 리소스를 수정합니다. DELETE DELETE를 통해 리소스를 삭제합니다. 다음과 같은 식으로 URI는 자원을 표현하는 데에 집중하고 행위에 대한 정의는 HTTP METHOD를 통해 하는 것이 REST한 API를 설계하는 중심 규칙입니다. 4-2. URI 설계 시 주의할 점 1) 슬래시 구분자(/)는 계층 관계를 나타내는 데 사용12http://restapi.example.com/houses/apartmentshttp://restapi.example.com/animals/mammals/whales 2) URI 마지막 문자로 슬래시(/)를 포함하지 않는다.URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것이고, 역으로 리소스가 다르면 URI도 달라져야 합니다. REST API는 분명한 URI를 만들어 통신을 해야 하기 때문에 혼동을 주지 않도록 URI 경로의 마지막에는 슬래시(/)를 사용하지 않습니다.12http://restapi.example.com/houses/apartments/ (X)http://restapi.example.com/houses/apartments (O) 3) 하이픈(-)은 URI 가독성을 높이는데 사용4) 밑줄(_)은 URI에 사용하지 않는다.5) URI 경로에는 소문자가 적합하다.6) 파일 확장자는 URI에 포함시키지 않는다. 4-3. 리소스 간의 관계를 표현하는 방법 REST 리소스 간에는 연관 관계가 있을 수 있고, 이런 경우 다음과 같은 표현방법으로 사용합니다.123/리소스명/리소스 ID/관계가 있는 다른 리소스명 ex) GET : /users/&#123;userid&#125;/devices (일반적으로 소유 ‘has’의 관계를 표현할 때) 만약에 관계명이 복잡하다면 이를 서브 리소스에 명시적으로 표현하는 방법이 있습니다. 예를 들어 사용자가 ‘좋아하는’ 디바이스 목록을 표현해야 할 경우 다음과 같은 형태로 사용될 수 있습니다.1GET : /users/&#123;userid&#125;/likes/devices (관계명이 애매하거나 구체적 표현이 필요할 때) 4-4. 자원을 표현한는 Collection과 Document Collection과 Document에 대해 알면 URI 설계가 한 층 더 쉬워집니다. DOCUMENT는 단순히 문서로 이해해도 되고, 한 객체라고 이해하셔도 될 것 같습니다. 컬렉션은 문서들의 집합, 객체들의 집합이라고 생각하시면 이해하시는데 좀더 편하실 것 같습니다. 컬렉션과 도큐먼트는 모두 리소스라고 표현할 수 있으며 URI에 표현됩니다. 예를 살펴보도록 하겠습니다.1http:// restapi.example.com/sports/soccer 위 URI를 보시면 sports라는 컬렉션과 soccer라는 도큐먼트로 표현되고 있다고 생각하면 됩니다. 좀 더 예를 들어보자면1http:// restapi.example.com/sports/soccer/players/13 sports, players 컬렉션과 soccer, 13(13번인 선수)를 의미하는 도큐먼트로 URI가 이루어지게 됩니다. 여기서 중요한 점은 컬렉션은 복수로 사용하고 있다는 점입니다. 좀 더 직관적인 REST API를 위해서는 컬렉션과 도큐먼트를 사용할 때 단수 복수도 지켜준다면 좀 더 이해하기 쉬운 URI를 설계할 수 있습니다. 5. HTTP 응답 상태 코드 마지막으로 응답 상태코드를 간단히 살펴보도록 하겠습니다. 잘 설계된 REST API는 URI만 잘 설계된 것이 아닌 그 리소스에 대한 응답을 잘 내어주는 것까지 포함되어야 합니다. 정확한 응답의 상태코드만으로도 많은 정보를 전달할 수가 있기 때문에 응답의 상태코드 값을 명확히 돌려주는 것은 생각보다 중요한 일이 될 수도 있습니다. 혹시 200이나 4XX관련 특정 코드 정도만 사용하고 있다면 처리 상태에 대한 좀 더 명확한 상태코드 값을 사용할 수 있기를 권장하는 바입니다.상태코드에 대해서는 몇 가지만 정리하도록 하겠습니다. 상태코드 200 클라이언트의 요청을 정상적으로 수행함 201 클라이언트가 어떠한 리소스 생성을 요청, 해당 리소스가 성공적으로 생성됨(POST를 통한 리소스 생성 작업 시) 상태코드 400 클라이언트의 요청이 부적절 할 경우 사용하는 응답 코드 401 클라이언트가 인증되지 않은 상태에서 보호된 리소스를 요청했을 때 사용하는 응답 코드 (로그인 하지 않은 유저가 로그인 했을 때, 요청 가능한 리소스를 요청했을 때) 403 유저 인증상태와 관계 없이 응답하고 싶지 않은 리소스를 클라이언트가 요청했을 때 사용하는 응답 코드 (403 보다는 400이나 404를 사용할 것을 권고. 403 자체가 리소스가 존재한다는 뜻이기 때문에) 405 클라이언트가 요청한 리소스에서는 사용 불가능한 Method를 이용했을 경우 사용하는 응답 코드 상태코드 301 클라이언트가 요청한 리소스에 대한 URI가 변경 되었을 때 사용하는 응답 코드 (응답 시 Location header에 변경된 URI를 적어 줘야 합니다.) 500 서버에 문제가 있을 경우 사용하는 응답 코드 글을 마치며 https://meetup.toast.com/posts/92 Reference","categories":[{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/categories/Blog/"}],"tags":[]},{"title":"Dynamic Programming(동적 계획법)","slug":"Algorithm-BasicAlgorithm-20190312-DynamicProgramming","date":"2019-03-12T13:39:44.000Z","updated":"2019-03-12T14:14:39.467Z","comments":true,"path":"2019/03/12/Algorithm-BasicAlgorithm-20190312-DynamicProgramming/","link":"","permalink":"http://yoursite.com/2019/03/12/Algorithm-BasicAlgorithm-20190312-DynamicProgramming/","excerpt":"","text":"Dynamic Programming(동적 계획법) 동적계획법이란 동적 계획법이란, 복잡한 문제를 여러 개의 작은 부분 문제(sub-problem)로 나누어 해결하는 문제 해결 기법입니다. 동적 계획법의 특징 중 하나는 이미 계산된 부분 문제가 다시 발생하면 새롭게 계산하지 않고 이전의 계산값을 참조하여 이용하는 것입니다. 이 방법은 부분 문제를 다시 해결하는 데 필요한 시간을 절약할 수 있지만, 이전 계산값을 저장해둘 공간이 필요하므로 시간과 메모리의 trade-off라고 할 수 있습니다. fib(N) = fib(N - 1) + fib(N - 2) (fib(0) = 1, fib(1) = 1)fib(7)을 단순 탐색으로 구현하려고 한다면 아래와 같은 sub-problem으로 나누어집니다. 출처 http://egloos.zum.com/kuphy00/v/2472789 위와 같이 fib(5)가 2번, fib(4)는 3번, fib(3)은 5번, fib(2)는 8번, fib(1)은 5번씩 호출됩니다. fib(N)에 대한 결과값은 언제나 일정하므로, 같은 파라미터를 가진 함수를 중복 호출은 굉장히 비효율적입니다. 이를 해결할 수 있는 것이 Memoization입니다.Memoization이란 한 번 계산된 값을 기록해두고 이후 중복 호출되었을 때 새롭게 계산하는 것이 아닌 저장해 둔 값을 가져와 사용하는 방법입니다. 예를 들어 fib(N)이 호출되었을 때, fib_value[N]이 이미 계산되어있는 값이라면 이를 그대로 돌려주고, 아니라면 fib(N-1)과 fib(N-2)을 호출하여 그 합을 fib_value[N]에 저장하는 것입니다. 이를 이용하면 아래와 같이 연산량이 줄어듭니다. Top-Down와 Bottom-Up 동적 계획법의 구현은 크게 Top-Down방식과 Bottom-Up방식으로 나뉘어집니다. Top-Down방식은 큰 문제에서 작은 부분문제를 재귀적으로 호출하여 리턴 되는 값을 이용하여 큰 문제를 해결하는 방식입니다. 중복되는 부분문제를 피하기 위해 앞서 소개한 Memoization기법을 함께 사용하며, 위에서 다룬 피보나치 함수의 구현방법 또한 이에 속합니다. 반대로 Bottom-Up방식은 작은 부분문제들을 미리 계산해두고, 이 부분문제들을 모아 큰 문제를 해결하는 방식입니다. 일반적으로 배열에 값을 채워나가는 형태로 구현합니다. 피보나치 함수를 Bottom-Up 방식으로 구현하면 아래와 같습니다. 두 가지 방법은 각각의 장단점이 있습니다. Top-Down방식의 경우, 재귀함수를 통해 구현되므로 함수 호출에 대한 오버헤드가 발생합니다. 반면 Bottom-Up방식의 경우 반복문을 통해 구현되므로 이러한 자원에 비교적 자유로워 시간 및 메모리의 최적화가 쉽습니다. 하지만 Bottom-Up방식의 경우 큰 문제를 해결하기까지 어떠한 sub-problem이 요구되는지 알 수 없으므로 전체 문제를 계산하기 위해 모든 부분문제를 해결해야 합니다. 하지만 Top-Down방식의 경우 큰 문제를 해결하기 위해 필요한 sub-problem만을 호출하므로 필요한 부분만 계산하게 되어 특정한 경우에는 Bottom-Up방식보다 빠르게 동작할 수 있습니다. Coin Change Problem 동적계획법의 또 다른 대표적인 예로 Coin Change Problem(동전 교환 문제)이 있습니다. 동전 교환 문제란 동전의 종류 N과 각 동전의 금액이 주어졌을 때 특정 금액 K를 만들기 위한 동전의 최소 개수를 구하는 문제입니다. 이때 각 동전의 개수는 무한히 많다고 가정합시다. 1, 5, 12원짜리 동전이 있고, 15원을 만들어야 하는 경우를 생각해봅시다. 이를 해결할 때 가장 먼저 떠오르는 것은 가장 큰 금액의 동전부터 먼저 사용하는 Greedy한 방법입니다. 동전을 적게 쓰기 위해서는 큰 동전을 쓰는 것이 유리하다는 생각으로 먼저 12원짜리 동전을, 이후 남은 3원을 1원짜리 동전 세 개로 채워 12 + 1 + 1 + 1의 총 4개의 동전으로 15원을 만듭니다. 하지만 이 경우는 최적값이 아닙니다. 5 + 5 + 5 총 3개의 동전으로 15원을 만드는 방법이 있기 때문입니다. 이를 해결하기 위해서는 어떻게 해야 할까요? 사용한 Greedy 방법을 계속 확장해봅시다. 다음 차례로는 12원짜리 동전을 하나 제외하고, 다음으로 큰 5원짜리 동전을 최대한 많이 사용하게 될 것입니다. 5 + 5 + 5라는 최적값을 찾게 됩니다. 하지만 만약 이보다 동전을 적게 사용하는 해가 있다면 어떻게 될까요? 또한 이 값이 최적값이라는 것을 어떻게 확신할 수 있을까요? 모릅니다. 결국 Greedy 방법은 모든 경우를 다 찾게 될 것입니다. 동전이 100개만 되더라도 그 경우의 수는 계산이 힘들 만큼 많아집니다. 이때 사용하게 되는 것이 동적계획법입니다. C[N] = {1, 5, 12}, D[i]: i원을 만들기 위해 필요한 동전의 최소개수라고 정의합시다. 우리는 D[K]에 대해 아래와 같은 점화식을 세울 수 있습니다. $$D[K] = { MIN }_{ i=0 to N-1, K &gt; C[i] } (D[K - C[i]]) + 1$$ 위 식은 K원을 만들기 위해서는 K보다 작은 금액에 새로운 동전이 더해지는 원리입니다. 더해지는 새로운 동전의 금액이 C[i]라면 D[K](K원을 만들기 위해 필요한 동전의 최소개수)의 후보값은 N개의 금액에 대해서 D[K - C[i]]((K - C[i])원을 만들기 위해 필요한 동전의 최소개수)에 C[i]원 동전 하나를 추가하는 방법들이 될 것입니다. 이는 결국 D[K]라는 큰 문제를 D[K - C[i]]라는 sub-problem으로 나누어 풀게 되는 동적 계획법이 됩니다. 입력첫 줄에 동전의 개수 N과 만들어야 하는 금액 K가 주어집니다. (1 ≤ N ≤ 100, 1 ≤ K ≤ 10,000)둘째 줄에 N개의 동전의 금액이 주어집니다. 모든 동전의 금액은 10,000보다 작거나 같은 양의 정수입니다.출력K원을 만들기 위해 필요한 동전의 최소개수를 출력합니다.만약 K원을 만드는게 불가능하다면 -1을 출력합니다. 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int coin[100], d[10001];int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; coin[i]; &#125; for(int i = 1; i &lt;= k; i++) &#123; d[i] = -1; for(int j = 0; j &lt; n; j++) &#123; if(coin[j] &lt;= i) &#123; if(d[i - coin[j]] &lt; 0) continue; if(d[i] &lt; 0) d[i] = d[i - coin[j]] + 1; else if(d[i - coin[j]] + 1 &lt; d[i]) d[i] = d[i - coin[j]] + 1; &#125; &#125; &#125; cout &lt;&lt; d[k] &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"BasicAlgorithm","slug":"Algorithm/BasicAlgorithm","permalink":"http://yoursite.com/categories/Algorithm/BasicAlgorithm/"}],"tags":[]},{"title":"머신러닝을 위한 기본 용어 정리","slug":"Python-20190225-MachineLearning","date":"2019-02-25T14:11:55.000Z","updated":"2019-02-25T14:17:57.949Z","comments":true,"path":"2019/02/25/Python-20190225-MachineLearning/","link":"","permalink":"http://yoursite.com/2019/02/25/Python-20190225-MachineLearning/","excerpt":"","text":"기본 용어 정리Variable보통 수학에서 x, y처럼 가변적인 값을 변수(Variable)라고 합니다. 머신러닝에서도 마찬가지입니다. 모델에서 바뀔 수 있는 값을 변수라고 합니다. 이 변수에는 학습을 위하여 기존 데이터가 들어갈 수도 있고, 학습된 결과를 바탕으로 예측을 위하여 새로운 데이터가 들어갈 수도 있습니다. 머신러닝에서 변수는 크게 입력변수 (Input Variables)와 출력변수(Output Variables)로 나눌 수 있습니다. Input Variables글자 그대로 입력(Input)으로 들어가는 변수입니다. 예를들어 “내신점수”, “모의고사점수”, “공부한 시간”으로 “수능성적”을 예측한다고 할 때, “내신점수”, “모의고사점수”, “공부한 시간”이 Input Variable입니다. Independent Variable 또는 Feature라고도 합니다. Output Variables입력 변수와 반대로 출력(Output)되는 변수를 의미합니다. 위의 예에서 수능성적에 해당합니다. Dependent Variable또는 Target이라고도 합니다. Training Data데이터 중에서 특정 1모델을 학습하기 위해 사용되는 데이터를 의미합니다. 1 모델을 학습한다는 의미는 데이터에 맞게 모델을 맞추는 과정(Fitting)을 뜻합니다. Test Data데이터 중에서 Training Data를 이용해 학습된 모델을 테스트하기 위해 사용되는 데이터 입니다. 머신러닝에서는 모델이 지나치게 데이터에 끼워 맞춰져서 학습에 사용된 데이터에서는 성능(Performance)가 좋게 나오지만, 새로운 데이터가 들어오면 제대로 된 예측을 하지못하는 과적합(Overfitting) 이슈가 있습니다. 이 때, 데이터를 Training Data와 Test Data로 나누어 Training Data에서 학습한 모델을 새로운 Test Data에서 테스트해보면서 Overfiiting 여부를 판단할 수 있습니다. Supervised LearningOutput Variable이 주어진 학습(Learning)을 의미합니다. 위에서 예를 든 수능성적 예측 같은 경우 수능 점수라는 Output Variable이 있기 때문에 Supervised Learning입니다. 여기에는 아래에서 설명할 Classification과 Prediction(Regression)이 있습니다. Unsupervised LearningOutput Variable이 주어지지 않은 학습(Learning)입니다. 즉, 뭔가를 예측하거나 결과값을 도출하는 것이 목표가 아니라, 데이터 내부에서 의미있는 패턴을 추출하거나 데이터 내부에서 유사한 성질을 가진 데이터들을 묶는(Clustering) 것을 목표로 합니다. 예를들어, 고객들의 소비 데이터를 이용해 유사한 소비 패턴을 가진 고객들을 묶는 Target Segmentation이 있습니다. Classification한국어로 분류문제라고 합니다. Output Variable이 카테고리로 나눠져 있어서 주어진 데이터가 어떤 카테고리에 속할지를 분류하는 문제입니다. 예를들어, 동물 사진이 주어졌을 때 개인지 고양이인지 판단하는 문제가 있다면 이는 분류문제입니다. 두 개의 카테고리가 존재한다면 Binary Classification 그 이상의 카테고리가 존재한다면 Multiple Classification이라고 합니다. 위의 예시는 Binary Classification (개/고양이)의 예입니다. Prediction (Regression)Output Variable이 연속형 변수(Continuous Variable)로 이루어져있는 경우를 말합니다. 예를 들어 한달 후 주식 수익률을 예측하는 문제가 있다면 이는 Prediction에 해당합니다. Prediction의 경우 단순히 Regression이라고 언급하는 사람들도 많으니 알아두시면 좋습니다. 단, 이후에 다루게 될 Logistic Regression의 경우 Classification 영역에 속합니다. Prediction문제를 Classification으로 푸는 경우도 있습니다. 바로 위에서 예를 든 주식 수익률 예측의 경우 수익률이 0보다 크면 오른다, 0보다 작으면 내린다, 0이면 변화없음으로 Output Variable을 치환하여 분류문제로 풀 수 있습니다. Classification과 Prediction은 Supervised Learning에 속합니다. Associated RulesAssociated Rules란 데이터의 상관관계를 찾아내는 방법입니다. 예를 들어, “대부분의 사람들이 A라는 제품을 구매했을 떄, B라는 제품도 구매했다” 또는 “A제품을 산 사람들은 C는 구매하지 않는다”와 같은 연관성을 찾아내는 것입니다. 이는 Recomendation System (추천 시스템)의 출발점으로 볼 수 있습니다. Data Reduction데이터가 너무 크거나 복잡할 때, 이를 보다 작거나 단순한 데이터로 바꾸는 과정을 의미합니다. Variables의 개수를 줄일 수도 있고, 데이터의 개수 (The number of observations)를 줄일 수도 있습니다. 데이터가 너무 복잡할 때 이를 단순화 시킴으로써 모델의 성능을 향상시키고 Overfitting을 피할 수 있습니다. Data Visualization글자 그대로 데이터를 그래프를 통해 그려보는 것입니다. 데이터를 그래프에 뿌리면 데이터의 특성 (예를들면 변수들간의 관계)를 보다 쉽게 파악할 수 있습니다. Associated Rules, Data Reduction, 그리고 Data Visualization은 Unsupervised Learning에 속한다고 볼 수 있습니다. sjquant님 글을 포스팅했습니다.","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"MachineLearning","slug":"Python/MachineLearning","permalink":"http://yoursite.com/categories/Python/MachineLearning/"}],"tags":[]},{"title":"BFS(Breadth-First Search, 너비 우선 탐색)","slug":"Algorithm-BasicAlgorithm-20190218-BFS","date":"2019-02-18T08:54:07.000Z","updated":"2019-02-18T08:58:27.404Z","comments":true,"path":"2019/02/18/Algorithm-BasicAlgorithm-20190218-BFS/","link":"","permalink":"http://yoursite.com/2019/02/18/Algorithm-BasicAlgorithm-20190218-BFS/","excerpt":"","text":"Breadth-First Search, 너비 우선 탐색너비 우선 탐색은 그래프의 모든 정점들을 특정한 순서에 따라 방문하는 알고리즘 중 하나입니다. 현재 정점과 인접한 간선들을 검사하다가 방문하지 않은 정점들을 발견하면 그 간선을 통해 방문하지 않은 정점들을 자료구조 큐에 넣습니다. 그리고 큐의 front 정점을 방문하고 pop합니다.또 해당 정점에서 인접한 간선을 검사해 방문하지 않은 정점들을 큐에 넣고 방문하기는 과정을 반복하다가 더 이상 방문할 수 있는 정점이 없으면 종료합니다. 이러한 과정을 반복하여 큐에 더 이상 정점이 존재하지 않을 때까지 실행하여 그래프의 모든 정점을 방문하는 알고리즘이 BFS 알고리즘입니다 여러분의 이해를 돕기 위해 움직이는 그림으로 그래프를 설명하도록 하겠습니다. 위의 그림과 같은 유향 그래프가 존재하고 한 정점에서 여러 개의 정점으로 이동이 가능할 때 정점의 번호가 더 작은 쪽을 먼저 방문한다고 가정을 하겠습니다. 이 때, 정점 1에서 너비 우선 탐색을 하게 된다고 합시다. 큐에 정점 1을 넣습니다. 그리고 큐의 front인 정점 1을 현재 정점으로 놓고 큐를 pop합니다. 정점1과 연결된 간선들을 통해 연결된 정점을 확인하면 2,3,7이 연결되어 있습니다. 이 때, 정점의 번호가 작은 쪽을 방문한다는 규칙에 의해 2를 먼저 큐에 넣어줍니다. 그리고 마찬가지로 3번 7번 정점도 큐에 넣어줍니다. 3개의 정점 모두 방문했다고 처리해줍니다. 그러면 다음으로 큐의 front인 2번 정점이 현재 정점이 됩니다. 마찬가지로 큐를 pop합니다. 3,4로 이동할 수 있지만 3번은 이미 방문처리가 된 정점이며 큐에 이미 들어있기 때문에 4번 정점을 큐에 넣어줍니다.이와 같은 식으로 규칙대로 이동하다보면 1-2-3-7-4-5-6와 같이 방문을 하게됩니다. 6번 정점은 4번 정점과 5번 정점과 연결되어 있으나 이미 방문된 정점들이므로 이동할 수 없습니다. 따라서 큐에는 더 이상 정점들이 존재하지 않게 되고 BFS는 끝나게 됩니다. 이 순서는 결과적으로 시작점과 가까운(이동에 필요한 간선의 수가 적은) 정점 순서로 방문하는 것이 됩니다. 해당 알고리즘을 구현하기 위해서는 해당 정점이 방문되었는지 확인하는 boolean타입의 1차원 배열과 정점들의 집합 그리고 정점과 정점 사이의 연결을 확인할 수 있는 간선 집합들이 필요합니다. 그리고 해당 알고리즘의 시간복잡도는 모든 정점을 방문하며 모든 간선을 검사하기 때문에 시간복잡도는 O(V+E)입니다. ( V: 정점의 개수, E: 간선의 개수)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"BasicAlgorithm","slug":"Algorithm/BasicAlgorithm","permalink":"http://yoursite.com/categories/Algorithm/BasicAlgorithm/"}],"tags":[]},{"title":"DFS(Depth-First Search, 깊이 우선 탐색)","slug":"Algorithm-BasicAlgorithm-20190218-DFS","date":"2019-02-18T08:47:40.000Z","updated":"2019-02-18T08:53:27.170Z","comments":true,"path":"2019/02/18/Algorithm-BasicAlgorithm-20190218-DFS/","link":"","permalink":"http://yoursite.com/2019/02/18/Algorithm-BasicAlgorithm-20190218-DFS/","excerpt":"","text":"Depth-First Search 깊이 우선 탐색깊이 우선 탐색은 그래프의 모든 정점들을 특정한 순서에 따라 방문하는 알고리즘 중 하나입니다. 현재 정점과 인접한 간선들을 검사하다가 방문하지 않은 정점을 발견하면 그 간선을 통해 방문하지 은 정점으로 이동하는 것입니다.이 과정을 반복하다가 더 이상 방문할 수 있는 정점이 없으면 마지막으로 통과한 간선을 통해 뒤로 돌아가서 해당 정점에서 방문할 수 있는 정점을 탐색합니다. 이러한 과정을 반복하여 그래프의 모든 정점을 방문하는 알고리즘이 DFS 알고리즘입니다. 여러분의 이해를 돕기 위해 움직이는 그림으로 그래프를 설명하도록 하겠습니다.위의 그림과 같은 유향 그래프가 존재하고 한 정점에서 여러 개의 정점으로 이동이 가능할 때 정점의 번호가 더 작은 쪽을 먼저 방문한다고 가정을 하겠습니다. 이 때, 정점 1에서 깊이 우선 탐색을 하게 된다고 합시다. 먼저, 정점 1에서 연결된 간선들을 통해 연결된 정점을 확인하면 2,3,7이 연결되어 있습니다. 이 때, 정점의 번호가 작은 쪽을 방문한다는 규칙에 의해 2번으로 이동합니다. 2번 정점은 3,4로 이동할 수 있지만 규칙에 의해 3번으로 이동합니다. 이와 같은 식으로 규칙대로 이동하다보면 1-2-3-5-7-6-4와 같이 방문을 하게됩니다. 4번 정점에서는 3을 방문할 수 있으나 3번은 이미 방문된 정점이므로 이동할 수 없습니다. 그러면 4번에선 더 이상 이동할 수 있는 정점이 없으므로 6번으로 돌아갑니다. 6번에서도 5번으로 이동할 수 있지만, 이미 방문된 정점이므로 7번으로 돌아갑니다. 위와 같은 식으로 계속 돌아가다보면 1번으로 돌아가게 됩니다. 1번에서도 3,7로 이동할 수 있지만 이미 방문한 정점이므로 DFS는 끝나게 됩니다. 해당 알고리즘을 구현하기 위해서는 해당 정점이 방문되었는지 확인하는 boolean타입의 1차원 배열과 정점들의 집합 그리고 정점과 정점 사이의 연결을 확인할 수 있는 간선 집합들이 필요합니다. 그리고 해당 알고리즘의 시간복잡도는 모든 정점을 방문하며 모든 간선을 검사하기 때문에 시간복잡도는 O(V+E)입니다. ( V: 정점의 개수, E: 간선의 개수)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"BasicAlgorithm","slug":"Algorithm/BasicAlgorithm","permalink":"http://yoursite.com/categories/Algorithm/BasicAlgorithm/"}],"tags":[]},{"title":"Binary Search (이진 탐색)+Ternary Search","slug":"Algorithm-BasicAlgorithm-20190213-BinarySearch","date":"2019-02-13T07:26:33.000Z","updated":"2019-02-13T08:31:16.064Z","comments":true,"path":"2019/02/13/Algorithm-BasicAlgorithm-20190213-BinarySearch/","link":"","permalink":"http://yoursite.com/2019/02/13/Algorithm-BasicAlgorithm-20190213-BinarySearch/","excerpt":"","text":"Binary Serch이진 탐색(Binary Search)은 정렬된 배열에서 원하는 값을 시간복잡도 O(log N) 만에 찾아내는 탐색하는 방법입니다. 오름차순으로 정렬된 사이즈가 N인 배열 D에서 원하는 값 k를 찾는 방법은 다음과 같습니다. 먼저 탐색할 데이터의 범위를 두 개의 인덱스(왼쪽, 오른쪽)로 지정하고 이를 L, R이라고 하겠습니다. 정렬되어있기 때문에 D[L]은 최솟값, D[R]은 최대값이 됩니다. 당연히 처음 탐색 시에는 전체영역이므로 L = 0, R = N - 1 입니다. 이중 중앙값(Median)을 찾아 찾으려는 값 k와 비교합니다. 중앙값 M은 (L+R)/2 로 구할 수 있습니다. 중앙값인 D[M]과 K를 비교하였을 시, K가 더 크므로 [0, M]범위에는 K값이 존재할 수 없습니다. 그러므로 L을 M+1로 옮겨주어 [M+1,R] 사이에서 K값을 찾도록 해보겠습니다. 아직도 D[M]이 K보다 작기 때문에, L을 M+1로 옮겨주겠습니다. D[M]이 K와 같으므로 원하는 값을 찾았습니다. 이와 같이, 중앙값(D[M])과 찾으려는 값을 비교하여 찾으려는 값이 중앙값보다 크다면 L = M + 1, 작다면 R = M - 1을 한 후 다시 M을 구하는 방법으로 찾으려는 값이 없는 범위를 절반씩 잘라가면서 구하는 방법이 이진 탐색입니다. 만약 찾으려는 값이 없다면 L &gt; R이 되어서 종료하면 됩니다. 이 경우에도, 최대한 찾으려는 값과 비슷한 값들을 찾아가기 때문에, 이 점 또한 유용하게 사용하실 수 있습니다. 이 알고리즘의 시간복잡도는 쿼리당 O(log N)으로 빠른 알고리즘입니다. 정렬 알고리즘 또한 힙정렬이나 퀵정렬 등의 빠른 알고리즘을 사용하시면 더 효율적입니다. ternary search algorithm나중에 한번 정리하려고 했던 터널리서치에 대해서 잠깐 언금하고 넘어가려고한다.Ternary search는 어떤 연속적인 단봉형(표준분포모양) 함수의 최대값, 혹은 최소값 (최적해)을 찾는 것을 목표로한다. 최소값이나, 최대값을 찾기위해서 는 한개의 지역의 극대점을 갖는 함수를 의미하는 것이다.예를 들어 극대점에 이르기 까지는 단조증가하고, 그 이후로는 단조 감소한다고 할수 있다. 이진탐색은 일차함수에서 답을 찾는 것이라고 생각하면 터널리서치는 2차함수에서 극대점이나 극소점을 찾는 알고리즘이라고 이해하면 될 것 같다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"BasicAlgorithm","slug":"Algorithm/BasicAlgorithm","permalink":"http://yoursite.com/categories/Algorithm/BasicAlgorithm/"}],"tags":[]},{"title":"Basic statistics(기초통계) 정리","slug":"Data-Science-20190212-BasicStatistics","date":"2019-02-12T00:35:30.000Z","updated":"2019-02-12T01:10:05.193Z","comments":true,"path":"2019/02/12/Data-Science-20190212-BasicStatistics/","link":"","permalink":"http://yoursite.com/2019/02/12/Data-Science-20190212-BasicStatistics/","excerpt":"","text":"기초 통계 정리키워드 목차1) 기술통계와 추리통계2) 모집단과 표본3) 척도4) 도수분포표와 그래프5) 공분산과 상관계수6) 가설과 신뢰수준/유의확률7) 양측 검증과 단측 검증8) t-분석9) 분산분석10) 회귀분석11) 로직스틱 회귀분석12) 조절효과와 매개효과13) 구조 방정식 모형14) 다수준분석 [기초통계]01_기술통계와 추리통계기술통계 수집한 자료를 분석하여 대상들의 속성을 파악하는 통계방법1) 중심경향값 : 전체 자룔르 대표할 수 있는 수치들○ 평균 : 전체 자료가 가지는 수치들의 총합을 전체 자료의 수로 나눈 수치○ 중앙값 : 최대값과 최소값의 정가운데 수치○ 최빈값 : 가장 많은 빈도를 보이는 수치2) 분산도 : 전체 자료가 얼마나 퍼져 있는 지를 알 수 있는 수치들○ 분산 : 각 자료가 평균으로 부터 떨어진 거리(편차)들을 제곱한 수치들의 총합을 전체 자료로 나눈 수치○ 표준편차 : 분산을 제곱근을 취한 수치3) 상관계수 : 두 변수 간의 관계의 크기4) 회귀계수 : 독립변수(원인)가 종속변수(결과)에 미치는 영향의 크기 추리통계(추론통계) 모집단을 대표하는 표본을 추출하고 표본의 기술통계를 이용하여 모집단의 속성들을 유추하는 통계방법 신뢰구간 추리통계에서 예측한 모집단의 특성이 위치할 가능성이 높은 구간 표본에서 구해지는 기술통계값들을 이용하여 계산되며, 95%, 99%, 99.9% 신뢰수준에서 따라 달라짐95% 신뢰구간보다 99% 신뢰구간 영역이 더 덟음 [기초통계]02_모집단과 표본모집단 연구 또는 분석이 이루어지는 전체 대상○ 모집단에서 추출한 표본집단표본 모집단에서 추출한 일부로, 모집단의 속성들을 유추하는데 사용a. 확률표본추출 방법 : 무작위로 표본을 추출하는 방법으로 모집단을 대표할 가능성이 높은 방법b. 비확률표본추출방법 : 조사자의 편의나 판단에 의해서 표본을 추출하는 방법을 ㅗ모집단을 대표하지 않을 가능성이 존재하는 방법 중심극한정리 표본이 30이상으로 충분히 클 때a. 모집단의 분포와 상관없이 표본은 정규분포b. 표본의 평균 = 모집단의 평균c. 표본의 분산 = (모집단의 분산) / (표본의 수) 자유도 평균을 유지하면서 자유롭게 어떠한 값도 가질 수 있는 사례의 수자유도는 표본에서 1을 차감한 수치 [기초통계]03_척도척도 포괄성 : 척도 안에 모든 경우의 수가 포함되어야 한다는 원칙 상호배타성 : 척도 안에 중복되는 경우의 수가 없어야 한다는 원칙 명목척도 측정이 이루어지는 항목들이 상호배타적인 특성만을 가진 척도○ 당신의 성별은? 서열척도 명목척도들 중 항목들 간에 서열이나 순위가 존재하는 척도○ 당신의 최종 학력은? 등간척도 서열척도들 중 항목들 간의 간격이 일정한 척도○ 당신의 직무에 대해 얼마나 만족하십니까? 비율척도 등간척도 중 아무 것도 없는 상태를 0으로 정할 수 있는 척도 [기초통계]04_도수분포표와 막대그래프도수분포표 수집된 자료를 쉽게 이해할 수 있도록 일목요연하게 정리된 표로, 특정 항목 또는 특정 범위에 속하는 빈도수를 나타낸 표 막대그래프 비연속형 변수(명목척도 및 서열척도)에 사용되는 그래프로, 각항목에 속하는 빈도수를 나타낸 그래프 히스토그램 연속형 변수(등간척도 및 서열척도)에 사용되는 그래프로, 일정 범위에 속하는 빈도수를 나타낸 그래프 선그래프 히스토그램의 끝 부분을 선으로 연결한 그래프 [기초통계]04_도수분포표와 막대그래프도수분포표 수집된 자료를 쉽게 이해할 수 있도록 일목요연하게 정리된 표로, 특정 항목 또는 특정 범위에 속하는 빈도수를 나타낸 표 막대그래프 비연속형 변수(명목척도 및 서열척도)에 사용되는 그래프로, 각항목에 속하는 빈도수를 나타낸 그래프 히스토그램 연속형 변수(등간척도 및 서열척도)에 사용되는 그래프로, 일정 범위에 속하는 빈도수를 나타낸 그래프 선그래프 히스토그램의 끝 부분을 선으로 연결한 그래프 [기초통계]05_공분산과 상관계수공분산 두 변수가 함께 각자의 평균으로부터 멀어지는 정도 한 변수가 자신의 평균으로부터 멀어질 때 다른 변수가 자신의 평균으로 부터 멀어지는 정도를 의미○ cov(A, B) = 상관계수 두 변수 간의 관계로, 하나의 변수가 변화함에 따라 다른 변수가 변화하는 정도를 의미○ r_AB = Cov(A,B) / S_a * S_b -1 에서 1 사이의 범위를 가짐 양의 상관관계, 음의 상관관계, 무의미한 상관관계 [기초통계]06_가설과 신뢰수준영가설(H_0) 연구가설과는 반대되는 가설이고, 실제 분석이 이루어지는 가설 연구가설(H_1) 분석을 통해서 알아보고자 하는 내용으로 이루어진 가설 통계분석에서 영가설(H0)이 채택 시 연구가설을 기각 통계분석에서 영가설(H0)이 기각 시 연구가설을 채택 유의확률 실제로는 영가설이 참(채택)임에도 불구하고 통계분석을 통해 영가설을 거짓(기각)으로 판단할 가능성(p-value) 즉, 연구결과가 실제 현상을 반영하지 못할 가능성 예를 들어, 영가설(H0)로 ‘A집단의 평균과 B집단의 평균 간에는 차이가 없다. ‘ 라고 설정할 경우, 실제 두집단 간에 차이 없음에도 차이가 있다고 결론 내릴 가능성 신뢰수준 실제로는 영가설이 참이고 통계분석을 통해서도 영가성을 참으로 판단할 가능성 즉, 실제 현상에서 발생하지 않은 연구가설을 기각할 가능성 예를 들어, 영가설(H0)로 ‘ A 집단의 평균과 B집단의 평균 간에는 차이가 없다. ‘ 라고 설정할 경우, 실제 두 집단 간에 차이가 없으며, 두 집단의 차이가 없다고 결론 내릴 가능성 신뢰수준이 높아질수록 영가설(H0)이 채택될 가능성이 높아지고, 반대로 연구가설(H1)이 채택될 가능성이 낮아짐 즉, 신뢰수준이 높아질수록 연구가설이 실제 현상을 반영할 가능성이 상승 가설의 판단 기준 95% 신뢰수준 ( 유의확률 0.05 미만 ) : * 99% 신뢰수준 ( 유의확률 0.01 미만 ) : ** 99.9%신뢰수준( 유의확률 0.001미만) : *** 90% 신뢰수준 ( 유의확률 0.1 미만 ) : ✞ [기초통계]07_양측 검증과 단측검증양측 검증 방향성을 고려하지 않은 채로 연구가설(H1)을 설정하는 검증 방법 단측 검증 방향성을 고려하여 연구가설을 설정할 때 사용하는 검증방법 양측검증a. A집단의 평균과 B집단의 평균 간에는 차이가 있을 것이다.b. A변수가 B변수에 미치는영향의 크기는 ‘0’이 아니다 단측검증a. A 집단의 평균보다 B집단의 평균이 클 것이다.(또는 작을 것이다.)b. A변수가 B변수에 미치는 영향의 크기는 ‘0’보다 클것이다.(또는 작을 것이다.) 연구가설(H1)의 채택 가능성 양측 검증 보다는 단측 검증일 경우에 연구가설(H1)이 채택될 가능성이 높다. 95%신뢰수준의 단측검증 = 90% 신뢰수준의 양측검증 [기초통계]08_t-분석t-분석방법 독립변수가 비연속형 변수(즉, 명목척도나 서열척도)이고, 종속변수가 연속형 변수(즉, 등간척도나 비율척도)일 때 사용하는 분석방법으로, 독립변수의 집단이 2개 이하일 때 사용하는 분석방법 t-분포를 사용하여 분석 1) 일표본 t-분석 하나의 모집단에서 표본을 추출할 때 사용되는 분석으로 표본의 평균이 예측한 특정 수치와 같은 지 아니면 다른 지를 검증하는 방법 H0 : 국내 중학생의 평균 키는 170cm이다. H1(양측 검증) : 국내 중학생의 평균 키는 170cm가 아니다. H1(단측 검증) : 국내 중학생의 평균 키는 170cm보다 크다(작다). 2) 독립표본 t-분석 두개의 모집단에서 각각의 표본을 추출할 때 사용되는 분석으로 두 집단의 표본들의 평균이 서로 같은 지 다른 지를 검증하는 방법 H0 : A집단의 평균과 B집단의 평균은 같다. H1 (양측 검증) : A집단의 평균과 B집단의 평균은 다르다. H1 (단측 검증) : A집단의 평균은 B집단의 평균 보다 크다(작다). 3) 대응표본 t-분석 하나의 모집단에서 표본을 추출하지만, 같은 표본에게 두 번의 측적이 이루어질 때 사용 H0 : 사전 수치와 사후 수치는 같다. H1 (양측 검증) : 사전 수치와 사후 수치는 다른다. H1 (단측 검증) : 사전 수치보다 사후 수치가 더 크다(작다). [기초통계]09_분산분석(ANOVA)분산분석 방법 독립변수가 비연속형 변수(즉, 명목척도나 서열척도)이고, 종속변수가 연속형 변수(즉, 등간척도나 비율척도)일 때 사용하는 분석방법으로, 독립변수의 집단이 3개 이상일 때 사용하는 분석방법 F-분포를 사용하여 분석 분산분석 대표 가설 H0 : 집단들의 평균은 모두 같다. H1 : 집단들의 평균은 서로 다르다. 분산분석의 원리 집단 간 분산과 집단 내 분산을 통해 분석○ 집단간 분산 &gt; 집단 내 분산 : 집단간 차이가 있음○ 집단간 분산 &lt; 집단 내 분산 : 집단간 차이가 크지 않음○ 실제 분석은 (집단 간 분산) / (집단 내 분산)을 활용—- 1보다 크면 차이 있음 사후 분석 : 어떠한 집단들 간에 평균 차이가 발생하는 지를 알아보기 위한 분석방법 [기초통계]10_회귀분석회귀분석 방법 독립변수와 종속변수가 모두 연속형 변수(즉, 등간척도나 비율척도)일 때 사용하는 분석방법 추정방식은 OLS(Ordinary least square) 로 이루어지는데, 이는 오차의 제곱을 최소화 하는 직선이라는 의미 회귀분석의 원리 y = b0 + b1 * x + e○ Y : 종속변수 , X : 독립변수, b0 : 절편, b1 : 기울기, e : 오차 대표가설 H0 : 독립변수가 종속변수에 미치는 영향의 크기는 ‘0’이다 H1 (양측 검증) : 독립변수가 종속변수에 미치는 영향의 크기는 ‘0’이 아니다. H1 (단측 검증) : 독립변수가 종속변수에 미치는 영향의 크기는 ‘0’보다 크다(작다). 회귀분석의 특징 회귀분석에서는 여러 개의 독립변수를 포함하는 것이 가능 여러 독리변수들을 표함하는 경우에는 서로 통제되어 자신의 독자적인 영향력으로 계산 y = b0 + b1x1 + b2x2 + b3x3 + b4x4 설명량 (R^2) 독립변수들에 의해서 설명되어지는 종속변수의 분산 R^2가 증가할수록 회귀식에서 설명되어지지 못하는 오차는 감소 증가된 설명량(△R^2)을 이용해서 독립변수의 포함 여부를 결정 [기초통계]11_로지스틱 회귀분석로지스틱 회귀분석 방법 독립변수가 연속형 변수이지만, 종속변수가 변연속형 변수(특히, 이분형변수)인 경우에는 로지스틱 회귀분석을 사용하는 분석방법 로지스틱 회귀분석의 원리 Odd Ratio = p / 1- p=&gt; 특정 사건이 발생할 확률과 발생하지 않을 확률간의 비율 로지스틱 회귀식○ ln(p / 1-p) = b0 + b1 * x =&gt; 회귀분석에서 종속변수(y)를 Odd 비에 자연로그를 취한 값으로 대체 b1 &gt; 0 : x가 증가할수록 특정 사건이 발생하지 않을 확률보다 발생할 확률이 높다는 의미 b1 &lt; 0 : x가 증가할수록 특정 사건이 발생할 확률보다 발생하지 않을 확률이 높다는 의미 로지스틱 회귀분석 대표 가설 H0 : 독립변수가 종속변수에 미치는 영향의 크기는 ‘0’이다. H1 (양측검증) : 독립변수가 종속변수에 미치는 영향의 크기는 ‘0’이 아니다. H1 (단측검증) : 독립변수가 종속변수에 미치는 영향의 크기는 ‘0’ 보다 크다. 모형적합도 모형이 적절하게 만들어졌는 지를 보여주는 지표 로지스틱 회귀분석에서는 모형에 포함된 독립변수들에 의해서 종속변수가 설명되어지는 부분 대표적으로 X^2 - 수치 , -2log 우도 등이 사용 [기초통계]12_조절효과와 매개효과조절효과 독립변수가 종속변수에 미치는 영향이 조절변수에 의해서 달라지는 지를 알아보는 분석방법 매개효과 독립변수와 종속변수 간의 직접적인 인과관계 이외에도 매개변수를 통한 간접적인 인과관계가 존재하는 지를 알아보는 분석방법 총 효과 = 직접효과 + 간접효과 (또는 매개효과) [기초통계]13_구조방정식모형구조방정식모형 변수들 간의 관계를 밝히는 구조모형과 각 변수와 이를 측정하는 문항들 간의 관계를 밝히는 측정모형을 함께 고려하는 분석방법 확인적 요인분석과 매개효과 분석에 주로 활용 확인적 요인분석 확인적 요인분석은 측정문항들의 타당도를 알아보기 위한 분석으로 구조방정식모형 중 측정모형만을 분석하는 방법 [기초통계]14_다수준분석단일수준분석 모든 변수가 하나의 수준으로 이루어진 경우 다수준분석 독립변수와 종속변수의 수준이 다른 경우 독립변수와 종속변수의 개인수준이지만 조절변수의 수준이 다른 경우","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://yoursite.com/categories/Data-Science/"}],"tags":[{"name":"기초통계","slug":"기초통계","permalink":"http://yoursite.com/tags/기초통계/"}]},{"title":"Sieve of Eratosthenes(에라토스테네스의 체)","slug":"Algorithm-BasicAlgorithm-20190211-SieveofEratosthenes","date":"2019-02-11T04:40:17.000Z","updated":"2019-02-11T04:50:50.987Z","comments":true,"path":"2019/02/11/Algorithm-BasicAlgorithm-20190211-SieveofEratosthenes/","link":"","permalink":"http://yoursite.com/2019/02/11/Algorithm-BasicAlgorithm-20190211-SieveofEratosthenes/","excerpt":"","text":"Sieve of Eratosthenes에라토스테네스의 체는 특정 범위의 수들이 소수(Prime)인지 아닌지를 판별하는 알고리즘입니다. 에라토스테네스의 체의 원리는 간단합니다.1~50까지 모든 소수를 구하고자 한다면, 먼저 아래와 같은 배열이 필요합니다. 이 배열은 해당 인덱스의 숫자가 소수인지 아닌지를 나타냅니다. 먼저 가장 작은 소수 2부터 시작합니다. 그리고 2의 배수에 해당하는 수들은 모두 소수가 아닙니다. 따라서 범위 안의 2의 배수들을 소수가 아니라고 체크해줍니다.(일반적으로 boolean타입이나 int형 변수를 만들어주어 체크) 아래에서 색이 칠해진 수는 소수가 아님을 나타냅니다. 다음은 3입니다. 3은 2의 배수가 아니므로 체크가 되어있지 않습니다. 따라서 3은 소수입니다. 아까 했던 방식처럼 범위 안의 3의 배수를 모두 소수가 아니라고 체크해줍니다. 다음은 4입니다. 4는 2의 배수를 체크할 때 체크된 숫자이므로 소수가 아닙니다. 따라서 그냥 넘어갑니다. 그러면 다음 수는 5입니다. 5는 체크된 숫자가 아니므로 소수입니다. 마찬가지로 5의 배수를 모두 체크 해줍니다. 다음 수인 6은 4와 마찬가지로 색이 칠해져 있습니다. 즉 6은 이미 어떤 소수의 배수였기 때문에 소수가 아니라는 것을 알 수 있습니다. 따라서 2부터 시작해서 구하고 싶은 최대값까지 차례대로 보며 남은 수 중 아직 지워지지 않은 가장 작은 값은 소수가 되며, 이 배수들을 지워나가면 우리는 범위 내의 모든 소수를 구할 수 있습니다.위의 과정을 50까지 반복하면 배열은 아래와 같이 변하고, 이때 칠해지지 않은 수 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47이 1 ~ 50 범위에 속하는 소수가 됩니다. 위와 같은 방식으로 아주 작은 소수부터 시작해서 해당 수들의 배수를 제외시켜 나가는 알고리즘을 에라토스테네스의 체라고 합니다. 이를 수도코드로 나타내면 다음과 같습니다. 123456789Boolean Array isPrime[N]=&#123;true, …,true&#125;For(i=2;i&lt;=N;i++)&#123; If(isPrime[i] is false) continue For(j=i+i;j&lt;=N;j+=i) &#123; isPrime[j]=false &#125;&#125; 위의 코드는 최적화가 가능합니다. 첫 번째 반복문의 범위를 1부터 N까지가 아닌 1부터 sqrt(N)까지라고 한다면 정확성은 유지하면서 속도가 좀 더 빨라집니다. 어째서 N이 아닌 sqrt(N)까지로 하는지 의문이 들 수 있으므로 추가 설명하겠습니다.제곱인 숫자 A가 있다고 가정합시다. 어떤 수 A의 약수의 개수는 홀수 개 입니다 (만약 이 수가 어떤 수의 제곱이 아니라면 짝수 개가 되겠죠). 그리고 A의 전체 약수 집합이 {a1, a2, a3, a4, a5, a6, a7, a8}이었다고 한다면 이는 A = a1a8 = a2a7 = a3a6 = a4a5로 나타낸 수 있습니다.즉, 어떤 수 N을 약수로 나눈 몫 또한 약수가 되게 됩니다. 따라서 해당 수가 어떤 수의 제곱이라면 왼쪽 그림과 같이 표현할 수 있고, 아니라면 오른쪽 그림과 같이 표현할 수 있습니다.그러면 A의 약수를 구할 때 1부터 A까지가 아닌 1부터 sqrt(A)까지 구해야 된다는 것은 자명합니다. 따라서 N이 소수인지 아닌지 확인하기 위해 N 까지 확인하면 N의 약수들의 배수들이 소수인지 판별되었다는 것 또한 자명하기 때문에 이 알고리즘은 위와 같이 최적화가 가능합니다. 123456789Boolean Array isPrime[N]=&#123;true, …,true&#125;For(i=2;i&lt;= sqrt(N);i++)&#123; If(isPrime[i] is false) continue For(j=i+i;j&lt;=N;j+=i) &#123; isPrime[j]=false &#125;&#125; 하지만 해당 범위 내에서 M번째 소수를 구하는 문제라면 위와 같이 최적화 해선 안됩니다. 위와 같이 최적화하고 범위 내의 소수를 구한다면 sqrt(N)까지 범위의 소수들만 구해지기 때문입니다. 따라서 해당 숫자가 소수인지 아닌지 판별할 경우에는 위와 같이 최적화하고 해당 소수를 출력하는 문제라면 최적화하지 않고 N까지 돌려야 합니다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"BasicAlgorithm","slug":"Algorithm/BasicAlgorithm","permalink":"http://yoursite.com/categories/Algorithm/BasicAlgorithm/"}],"tags":[]},{"title":"자료구조_Hash(해쉬)","slug":"Computer-Science-Data-Structure-20190211-Hash","date":"2019-02-11T01:35:32.000Z","updated":"2019-02-11T04:11:27.889Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-Hash/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-Hash/","excerpt":"","text":"HASHING해싱은 임의의 길이의 데이터(키, Key)를 고정된 길이의 데이터(해시값, Hash value)로 변환해 작은 크기의 해시 테이블로 대응(Mapping)시켜 식별하는 하나의 기법입니다. 해시 테이블은 M개의 버킷으로 이루어져 있으며, 이 글에서 다루는 해시값은 해당 키가 저장될 버킷의 번호(해시 테이블의 인덱스)를 나타냅니다. 키에서 해시값을 추출하는 일련의 과정을 해시 함수(Hash function)라고 합니다. 해시 함수는 같은 키에 대해서는 동일한 해시값을, 다른 키에 대해서는 다른 해시값을 추출해야 합니다. 하지만 일반적으로 해싱에서 해시값의 범위(M)는 키의 범위보다 작기 때문에 어떤 이상적인 해시 함수라도 비둘기집의 원리에 의해 서로 다른 두 키가 같은 해시값을 가질 수 있습니다. 이런 경우를 충돌(Collision)이라고 합니다. 해싱이 사용되는 예로 문자열(Key)을 정숫값(Hash value)으로 치환하여 문제를 해결하는 방법이 있습니다. 이에 사용되는 가장 대표적인 해시 함수는 진법을 이용하는 것입니다. “SCPC”이라는 단어가 있다고 하면, 아래와 같이 진법을 이용한 해시 함수를 만들 수 있습니다. f(key) = ((((key[0]) 26 + key[1]) 26 + key[2])) * 26 … key[l – 1])f(“SCPC”) = 19 26^3 + 3 26^2 + 16 26^1 + 3 26^0 = 336391 해시 함수의 시간 복잡도를 O(H)라고 할 때 해시값의 중복이 없는 이상적인 해싱에서 키의 검색, 삽입, 삭제에는 모두 O(H)의 시간이 걸립니다.하지만 앞서 말했듯 해시값의 범위가 키의 범위보다 작을 때에는 충돌이 발생할 수밖에 없습니다.예를 들어 위와 같은 진법 변환을 해시 함수로 사용할 때에는 문자열이 길어지면 해시값이 너무 커지므로 적당히 큰 수로 나머지 연산한 값, 이 글에서는 해시 테이블의 크기 M으로 나머지 연산한 값을 해시값으로 쓸 수 있습니다.이때 해시값의 M에 대한 나머지가 같은 키끼리는 충돌이 발생합니다. 해시 함수와 마찬가지로 충돌을 제어하는 방법도 다양합니다. 여기에서는 대표적인 충돌 제어 방법 중 하나인 체이닝(Chaining)에 대해서 설명하겠습니다.체이닝은 충돌한 키들을 보존하기 위해 각 버킷을 리스트 형태로 구현합니다. 최초의 버킷은 모두 원소가 0개인 리스트의 헤더이며, 해당 버킷에 데이터가 추가될 때마다 노드를 추가합니다.이때 어떤 키가 해시 테이블에 존재하는지 검사하기 위해서는 해당 키의 해시값에 해당하는 버킷이 가진 노드를 모두 순회해야 합니다.이는 리스트에서 원소를 찾는 연산과 동일하며 이에 기반한 삭제 연산도 같은 선형 시간이 걸립니다.이때 몇 개의 버킷에만 데이터가 편중되는 최악의 경우 각 연산의 시간 복잡도는 O(H + N)이 됩니다. 이런 상황을 최소한으로 하기 위해서는 해시값의 추출 과정, 즉 해시 함수를 어떻게 구성할 것인지가 핵심이 됩니다.좋은 해시 함수란 해시값을 추출하는 연산이 빠르되 충돌이 적고 해시 테이블의 영역을 고르게 사용할 수 있어야 합니다.예를 들어 위에서 다룬 A * pow(B) mod M 형태의 진법 변환을 사용할 때 A의 값을 0이 아닌 1부터 시작하는 것이 좋습니다.0을 사용하게 되면 “A”와 “AAA”의 해시값이 같아지기 때문입니다. 또한 B와 M이 서로소인 것이 충돌 확률이 낮아 더 좋은 해시 함수가 될 수 있습니다. 해시 함수의 구현과 충돌 제어 방법, 좋은 해시 함수의 조건에 관해서는 굉장히 많은 자료가 있으므로 보다 깊은 이해를 위해 직접 찾아보시기 바랍니다. 글의 첫 부분에서 말했듯 해싱의 핵심은 값의 식별입니다. 그렇기에 원소의 중복을 허용하지 않는 Set이나 Key:Value쌍에서 중복된 Key가 존재하면 안 되는 Map과 같은 자료구조를 구현하는 데에 사용되기도 합니다. 아래는 C언어로 빡세게 해싱을 사용해 set을 구현한 코드입니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define BUCKET_COUNT 10007#define MAX_STRING_LENGTH 100typedef struct node &#123; struct node* next; int hash_value;&#125; node;int get_hash_value(char* key) &#123; int value = 0, len = strlen(key); for(int i = 0; i &lt; len; i++) value = (value * 27 + key[i] - 'A' + 1) % MAX_STRING_LENGTH; return value;&#125;void insert(node** head, char* key) &#123; int hash_value = get_hash_value(key); for(node* current_node = (*head)-&gt;next; current_node-&gt;next != NULL; current_node = current_node-&gt;next) &#123; if(current_node-&gt;hash_value == hash_value) &#123; return ; &#125; &#125; node* new_node = (node *)malloc(sizeof(node)); new_node-&gt;hash_value = hash_value; if (!(*head)) &#123; new_node-&gt;next = NULL; (*head) = new_node; &#125; else &#123; new_node-&gt;next = (*head); (*head) = new_node; &#125; return;&#125;void erase(node** head, char* key) &#123; int hash_value = get_hash_value(key); for(node* precedent_node = *head; precedent_node-&gt;next != NULL; precedent_node = precedent_node-&gt;next) &#123; if(precedent_node-&gt;next-&gt;hash_value == hash_value) &#123; precedent_node-&gt;next = precedent_node-&gt;next-&gt;next; &#125; &#125; return;&#125;int count(node** head, char* key) &#123; int counter = 0; int hash_value = get_hash_value(key); for(node* current_node = (*head)-&gt;next; current_node-&gt;next != NULL; current_node = current_node-&gt;next) &#123; if(current_node-&gt;hash_value == hash_value) &#123; counter++; &#125; &#125; return counter;&#125;int main() &#123; int n; scanf(\"%d\", &amp;n); node* hash[BUCKET_COUNT]; for(int i = 0; i &lt; n; i++) &#123; int command; char key[MAX_STRING_LENGTH + 1]; scanf(\"%d %s\", &amp;command, key); if(command == 1) &#123; insert(hash, key); &#125; else if(command == 2) &#123; erase(hash, key); &#125; else &#123; if(0 &lt; count(hash, key)) &#123; printf(\"1\\n\"); &#125; else &#123; printf(\"0\\n\"); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://yoursite.com/tags/자료구조/"}]},{"title":"자료구조_Heap(힙)","slug":"Computer-Science-Data-Structure-20190211-Heap","date":"2019-02-11T01:35:27.000Z","updated":"2019-02-11T02:44:45.440Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-Heap/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-Heap/","excerpt":"","text":"HEAP(힙)힙(heap) 은 최댓값 또는 최솟값을 빠르게 찾아낼 수 있는 트리형 자료구조입니다.힙은 완전이진트리 형식을 따르며 모든 부모 노드의 값이 자식 노드들의 값과 일정한 대소 관계를 가지게 되는 규칙을 가지고 있습니다.또한 자식노드 사이의 상관관계는 없으므로 유의하여야 합니다.부모 노드의 값이 자식 노드의 값보다 크다면 최대 힙(Max Heap), 부모 노드의 값이 자식 노드의 값보다 작다면 최소 힙(Min Heap) 으로 부릅니다.힙의 규칙에 따라 트리의 가장 상단에는 최댓값 또는 최솟값이 있는 것이 자명하기 때문에, O(1) 만에 최댓값과 최솟값을 찾을 수 있습니다. 힙의 삽입은 트리의 가장 마지막 부분에 데이터를 삽입한 후, 부모 노드와 삽입 부분 노드의 대소 관계를 확인하여 힙의 규칙에 맞도록 부모 노드를 탐색, 스왑하는 과정으로 이루어져 있습니다. 힙의 삭제는 삭제할 원소를 삭제 한 후 트리의 가장 마지막 원소를 삭제된 원소의 위치에 넣어준 후 힙의 조건을 만족하는 적절한 위치에 이를 수 있도록 조정해주면 됩니다. 제일 마지막 원소를 삭제된 원소의 자리로 옮긴다. 힙의 규칙에 맞도록 부모와 자식노드를 바꾸어 준다.삭제가 완료된 힙 힙의 삽입과 삭제의 시간 복잡도는 최악의 경우 최하단 노드로부터 최상단 노드까지 스왑이 필요하게 됩니다. 따라서 O(log N)의 시간 복잡도를 가집니다. 완전이진트리를 사용하기 때문에 최대 사이즈의 배열로 선언 후 쉽게 구현하실 수 있습니다. 다음은 최소 힙을 사용한 오름차순 정렬을 하는 프로그램의 코드입니다. 123456입력첫 번째 줄에 정렬할 원소의 수 N,두 번째 줄에는 정렬해야 할 원소 n개가 입력된다.출력정렬 후의 원소들을 출력한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX 5005using namespace std;int heap[MAX];int main()&#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int m; cin &gt;&gt; m; heap[i] = m; for (int j = i; j &gt; 1; j /= 2) &#123; if (heap[j] &gt; heap[j / 2]) &#123; swap(heap[j], heap[j / 2]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; swap(heap[1], heap[n - i + 1]); for (int j = 1; ; ) &#123; int k = j * 2; if (k &gt; n - i) break; if (k + 1 &lt;= n - i &amp;&amp; heap[k] &lt; heap[k + 1]) k++; if (heap[j] &lt; heap[k]) &#123; swap(heap[j], heap[k]); j = k; &#125; else break; &#125; &#125; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; heap[i] &lt;&lt; \" \"; return 0;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[]},{"title":"자료구조_Tree(트리)","slug":"Computer-Science-Data-Structure-20190211-Tree","date":"2019-02-11T01:35:23.000Z","updated":"2019-02-11T04:14:56.571Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-Tree/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-Tree/","excerpt":"","text":"TREE(트리)트리는 자식과 부모의 관계로 이루어진 계층적인 구조입니다. 필요에 따라 다양한 종류로 나뉘게 되는데 이번 문서에서는 제일 간단한 트리인 이진 트리에 대해서 설명하려고 합니다. 먼저 이진 트리에서 사용하는 용어들을 정리해보면 다음과 같습니다. 123456789Root : 트리에서 가장 최상위에 존재하는 노드Child : 어떠한 노드의 자식 노드Parent : 어떠한 노드의 부모 노드Siblings : 같은 부모를 갖는 형제 노드Leaf/Terminal : 자식 노드를 갖지 않는 노드Branch/Internal : 자식 노드를 적어도 1개 이상 갖는 노드Degree : 노드가 가지고 있는 자식 노드의 개수Height : 해당 노드부터 Leaf 노드까지의 가장 긴 거리Level : 트리 각 층의 단계 (루트 노드의 경우 1) 위에서 트리에서 사용하는 용어들을 알아보았습니다. 여러분의 이해를 돕기 위해 아래의 그림을 통해서 용어들을 설명하도록 하겠습니다. 1번 노드를 self 현재 노드라고 한다면, 0은 1번 노드의 Parent입니다.( 0은 트리의 최상단에 위치하기 때문에 root 노드입니다). 그리고 3번과 4번 노드는 1의 자식 노드들 입니다. 2번 노드는 1번 노드의 부모인 0번 노드의 자식 노드이므로 sibling입니다.(자매 노드). 또한 자식이 하나도 존재하지 않으면 Leaf/Terminal 노드입니다. 이러한 노드들은 그림에서 연두색으로 표시하였습니다. 만약 자식이 1명이라도 존재한다면 Branch/ Internal 노드입니다. 이러한 노드들은 그림에서 파랑색으로 표현했습니다. 1번 노드의 Degree는 자식 노드의 수인 2입니다. Height는 1번 노드보다 하위 노드들 중 가장 아래에 있는 노드 7번 노드와의 거리인 2입니다. 1번 노드의 level은 2입니다.(루트 노드는 Level이 1) 이제 위에서 정리했던 용어들의 설명이 다 끝났습니다. 다음으로 트리의 탐색 방법에 대해서 설명을 하도록 하겠습니다. 트리 노드들의 값들을 확인하기 위해선 어떤 방법을 사용할까요? 만약 트리가 선형구조로 되어 있다면 그냥 포인터를 하나 두고 한 칸 씩 뒤로 옮기면서 확인하면 되었겠지만 아쉽게도 트리는 비선형 구조입니다. 따라서 일반적인 선형탐색 방법으로는 모든 노드들을 확인할 수 없습니다. 트리에서는 이러한 탐색과정을 Traversal(순회)이라고 합니다. 순회의 방법에는 여러가지가 있지만 대표적으로 사용하는 방법은 3가지가 있습니다. 그 방법은 Pre-Order traversal(전위 순회), In-Order traversal(중위 순회), Post-Order traversal(후위 순회) 입니다. 이 3가지 순회의 차이점은 방문 시 수행할 기능을 어느 시점에 호출하는가 입니다. 먼저 Pre-Order의 수행 방법입니다. (방문 시 수행할 기능은 값 출력이라고 하겠습니다.)1234567891011Pre-Order(현재 트리 노드의 위치 cur)&#123; Print(cur’s value) If(cur’s left exist)&#123; Pre-Order(cur-&gt;left) &#125; If(cur’s right exist)&#123; Pre-Order(cur-&gt;right) &#125;&#125; 두 번째로 In-Order의 수행 방법입니다.1234567891011In-Order(현재 트리 노드의 위치 cur)&#123; If(cur’s left exist)&#123; In-Order(cur-&gt;left) &#125; Print(cur’s value) If(cur’s right exist)&#123; In-Order(cur-&gt;right) &#125;&#125; 마지막으로 Post-Order의 수행 방법입니다.1234567891011Post-Order(현재 트리 노드의 위치 cur)&#123; If(cur’s left exist)&#123; Post-Order(cur-&gt;left) &#125; If(cur’s right exist)&#123; Post-Order(cur-&gt;right) &#125; Print(cur’s value)&#125; 위의 3가지 트리 순회를 보면 Print, 즉 노드를 방문했을 때 수행할 기능의 순서만 변화하는 것을 알 수 있습니다. 그러면 위에서 사용했던 예시인 &lt;그림 1&gt;을 이용하겠습니다. 트리의 순회는 root에서부터 시작합니다. 먼저, Pre-Order(0 : root)을 실행했을 때 출력 결과에 대해서 말씀드리겠습니다. Pre-Order는 자기 자신-왼쪽-오른쪽 순서로 작업을 수행하는 방식입니다.1) 루트인 0번 노드에서 출발하므로 0을 출력합니다. 그리고 왼쪽 노드가 존재하므로 Pre-Order(1)을 호출합니다.2) 1번 노드에서 1을 출력하고 마찬가지로 왼쪽 노드가 존재하므로 Pre-Order(3)을 호출합니다.3) 3번 노드에서 3을 출력하고, 왼쪽 노드가 존재하므로 Pre-Order(7)을 호출합니다.4) 7번 노드에서 7을 출력하게 됩니다. 7번 노드는 왼쪽 노드가 없습니다. 따라서 오른쪽 노드를 확인합니다. 하지만 오른쪽 노드 역시 존재하지 않으므로 Pre-Order(7)은 종료됩니다.5) 다시 Pre-Order(3)으로 돌아갑니다.(재귀 함수) 방금 Pre-Order(3)에서 왼쪽 노드를 확인했기 때문에 오른쪽 노드를 확인합니다. 하지만 오른쪽 노드가 존재하지 않으므로 Pre-Order(3) 역시 종료됩니다.6) Pre-Order(1)로 돌아가게 됩니다. 마찬가지로 왼쪽 노드를 확인했으므로 오른쪽 노드를 확인하는데 4번 노드가 오른쪽 노드이므로, Pre-Order(4)를 호출합니다.7) 4번 노드에서 4가 출력됩니다. 4번 노드도 7번과 같이 Leaf/Terminal 노드이므로 그냥 종료됩니다.8) Pre-Order(1)로 돌아가고 Pre-Order(1)도 종료되어 Pre-Order(0) 으로 돌아갑니다. 이러한 방식으로 방문하게 되면 출력결과는 0-1-3-7-4-2-5-6으로 출력하게 됩니다. 이번에는 In-Order를 실행했을 때 출력 결과에 대해서 말씀드리겠습니다. In-Order는 왼쪽-자기 자신-오른쪽 순서로 작업을 수행하는 방식입니다. 1) 우선 루트인 0번 노드에서 출발합니다. 하지만 Pre-Order와는 다르게 이때 0을 출력하지 않고 왼쪽 자식 노드의 유무를 확인합니다. 이때 왼쪽 노드가 존재하므로 In-Order(1)을 호출합니다.2) 1번 노드에서도 1을 바로 출력하지 않고, 왼쪽 노드가 존재하므로 In-Order(3)을 호출합니다.3) 3번 노드에서도 3에서도 3을 바로 출력하지 않고, 왼쪽 노드가 존재하므로 In-Order(7)을 호출하게 됩니다.4) 7번 노드는 Leaf/Terminal 노드이므로 왼쪽 노드가 없어 7을 출력하고 오른쪽 노드의 유무를 하지만 오른쪽 노드도 없으므로 종료됩니다.5) 다시 In-Order(3)으로 돌아가서 3을 출력하고 오른쪽 노드를 확인하지만 존재하지 않으므로 종료됩니다.6) 다시 In-Order(1)로 돌아가서 1을 출력하고 오른쪽 노드로 4가 존재하므로 In-Order(4)를 호출합니다.7) 4번 노드 역시 Leaf/Terminal 노드이므로 4를 출력하고 종료됩니다.8) 다시 In-Order(1)로 돌아가서 종료되고, In-Order(0)으로 돌아가서 0을 출력합니다. 이러한 방식으로 방문하게 되면 출력값은 7-3-1-4-0-5-2-6이 됩니다. 이것은 x좌표 순으로 정렬했을 때의 순서와 동일합니다. 따라서 자신보다 작은 값은 왼쪽 서브 트리, 큰 값은 오른쪽 서브 트리에 저장하는 이진 탐색 트리라면 In-Order Traversal 방식을 이용했을 때 정렬된 값이 나오게 됩니다. 마지막으로 Post-Order를 설명하겠습니다. 이 방식은 왼쪽-오른쪽-자기자신 순서로 수행하는 방식입니다. 1) 우선 루트인 0번 노드에서 시작하고, 왼쪽 노드가 존재하므로 Post-Order(1)을 호출합니다.2) 1번 노드에서도 왼쪽 노드가 존재하므로 Post-Order(3)을 호출합니다.3) 3번 노드 역시 왼쪽 노드가 존재하므로 Post-Order(7)을 호출합니다.4) 7번 노드는 Leaf/Terminal 노드이므로 7을 출력하고 종료됩니다.5) 다시 Post-Order(3)으로 돌아가서 3번 노드는 오른쪽 노드가 없으므로 3을 출력하고 종료됩니다.6) 1번 노드는 오른쪽 노드가 존재하므로 Post-Order(1)로 돌아가서 오른쪽 노드인 Post-Order(4)을 호출합니다.7) 4번 노드는 Leaf/Terminal 노드이므로 4를 출력하고 종료됩니다.8) 다시 Post-Order(1)로 돌아가서 1을 출력하고 종료됩니다. 이와 같은 방식으로 방문하면 출력값은 7-3-4-1-5-6-2-0이 됩니다. 이러한 트리의 순회 방법들로 트리에서 원하는 값을 탐색할 수 있습니다. 그러면 다음으로는 트리의 삽입에 대해서 알아보도록 하겠습니다. 이진 트리로 설명을 하자면, 각 노드의 왼쪽 오른쪽 노드를 저장하기 위해 아래와 같은 2차원 배열을 만들어줍니다. Child[Node_Num][LR] : Node_Num은 해당 노드의 번호, LR은 0일 경우 왼쪽 자식 노드 1일 경우 오른쪽 자식 노드를 의미합니다. 따라서 0번 노드의 왼쪽 노드가 1번 노드라는 것을 표현하고 싶다면 Child[0][0] = 1과 같이 쓰면 되고, 0번 노드의 오른쪽 노드가 3번 노드라는 것을 표현하고 싶다면 Child[0][1] = 3과 같이 쓰면 됩니다. 그리고 만약 트리 노드마다 값이 존재한다면 1차원 배열인 Value를 만들어주어 각 노드의 값을 표현해주면 됩니다.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://yoursite.com/tags/자료구조/"}]},{"title":"자료구조_Graph(그래프)","slug":"Computer-Science-Data-Structure-20190211-Graph","date":"2019-02-11T01:35:16.000Z","updated":"2019-02-11T04:11:29.842Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-Graph/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-Graph/","excerpt":"","text":"GRAPH그래프란 어떤 상태 혹은 객체 간의 관계를 나타내는 자료구조입니다. 그래프는 정점(Vertex)과 간선(Edge)으로 구성됩니다.정점이란 어떠한 상태 혹은 객체를 나타냅니다. 간선은 그러한 정점 간의 관계, 그중에서도 연결성을 표현하는 요소입니다. 아래 그림은 그래프의 개념이 퍼지기 시작한 ‘쾨니히스베르크의 다리 건너기 문제’의 쾨니히스베르크의 다리를 도식화한 두 그림입니다.A, B, C, D로 나눠진 4개의 구역과 각 구역을 잇는 a, b, c, d, e, f, g 7개의 다리가 있습니다. 왼쪽이 일반적으로 사용되는 그림이며, 이를 그래프 형태로 나타낸 것이 오른쪽의 그림입니다.여기서 원으로 표현된 A, B, C, D가 정점이며 이 정점들을 연결하는 실선 a, b, c, d, e, f, g가 두 지역을 오고 갈 수 있음을 의미하는 간선이 됩니다. 이를 수학적으로 표현하면 아래와 같습니다. 전체그래프 G = (V, E)정점 집합 V(G) = {A, B, C, D}간선 집합 E(G) = {a, b, c, d, e, f, g} 이러한 정점과 간선의 관계를 표현하는 말로 인접(adjacent)과 부속(incident)이 있습니다. 정점 u, v가 있고 이 두 정점을 잇는 간선 e가 있다고 가정합시다. 이때 정점 u, v는 e로 인해 서로 인접합니다. 같은 상황에서 간선 e는 정점 u, v에 부속합니다. 그래프에는 크게 무방향 그래프(undirected graph, 무향 그래프)와 단방향 그래프(directed graph, 유향 그래프)가 있습니다.무방향 그래프란 위의 쾨니히스베르크의 다리와 같이 모든 간선이 양방향으로 연결된 그래프입니다. 정점 u, v에 대해 무방향 그래프에서는 u-&gt;v라면 v-&gt;u이며, u-&gt;v가 불가능하다면 v-&gt;u 역시 불가능합니다.반면 단방향 그래프는 각 간선이 방향을 가집니다. 따라서 정점 u에서 정점 v로 가는 간선 e가 있다면 이는 u-&gt;v를 의미할 뿐, v-&gt;u를 의미하는 것은 아닙니다.단방향 그래프에서 u-&gt;v를 연결하는 간선이 있을 때 u는 v에 인접한다, v는 u로부터 인접하다 라고 표현할 수 있습니다. 간선은 따로 이름을 주지 않더라도 부속한 두 정점으로 표현할 수 있습니다. 무방향 그래프의 경우 u와 v를 연결하는 간선은 (u, v)와 같이 표현합니다. 단방향 그래프의 경우 u에서 나가 v로 들어오는 간선을 로 표현합니다.따라서 위의 무방향 그래프 G1과 단방향 그래프 G2를 아래와 같이 표현할 수 있습니다. G1 = (V, E) V(G1) = {A, B, C} E(G1) = {(A, B), (B, C)} G2 = (V, E) V(G2) = {A, B, C}E(G2) = {&lt;A, B&gt;, &lt;B, C&gt;} 그래프에서 쓰이는 또 다른 개념으로는 차수(degree)가 있습니다. 차수란 각 정점에 부속된 간선의 수로, 무방향 그래프에서 어떤 정점 v의 차수란 v에 부속된 간선의 개수입니다. 단방향 그래프에서 정점의 차수는 입력차수(in-degree)와 출력차수(out-degree)로 나누어집니다. 정점 v의 입력차수는 v로 들어오는 간선의 수이며 출력차수는 v에서 나가는 간선의 수와 같습니다. 이러한 그래프를 코드로 표현하는 데에는 크게 두 가지 방법이 사용됩니다. 첫 번째는 인접 행렬(adjacency matrix)을 이용한 표현입니다. 인접 행렬이란 각 정점이 다른 정점과 연결된 상태에 관한 정보를 나타내는 정사각행렬입니다. 예를 들어, 정점 u에서 나가 정점 v로 들어오는 간선이 있다면 1, 아니면 0으로 인접 행렬을 채웁니다. 무방향 그래프의 경우, u-&gt;v간선이 v-&gt;u 간선과 동일하므로 대각선(diagonal)을 중심으로 대칭(symmetric)됩니다. 아래는 정점이 4개인 단방향 그래프의 예시입니다. 두 번째 방법은 인접 리스트(adjacency list)를 이용한 표현입니다. 인접 리스트란 한 정점과 인접한 정점들을 리스트로 표현하는 형태입니다.아래는 정점이 4개인 단방향 그래프에서 정점 u에서 나가 v로 들어오는 간선들의 정보를 인접 리스트로 나타낸 예시입니다. 그렇다면 두 개의 표현법은 어떻게 다를까요?2차원 인접 행렬의 이름을 adj_matrix, 인접 리스트의 이름을 adj_list라고 할 때 두 표현법은 아래와 같은 장단점을 가집니다.두 정점 u, v가 인접한지를 확인하는 연산을 생각해봅시다. 인접 행렬의 경우 이 연산은 adj_matrix[u][v]의 값을 참조하기만 하면 됩니다. 즉 O(1)의 시간복잡도를 가집니다.하지만 인접 리스트는 adj_list[u]에 연결된 원소들을 순회하며 v가 존재하는지 확인해야 합니다. 최악의 경우 이 연산은 O(|V|)의 시간복잡도를 가집니다.반면 정점 u에 연결된 모든 정점을 탐색하는 상황을 생각해봅시다. 인접 행렬의 경우 어떤 정점들이 연결되어있는지 알기 위해서 모든 adj_matrix[u][i]를 참조해야 합니다. 따라서 O(|V|)의 시간이 걸립니다.하지만 인접 리스트의 경우에는 adj_list[u]에 연결된 정점의 개수만큼만 걸립니다. 물론 최악의 경우 O(|V|)지만 이 탐색이 전체 그래프로 확장된다면 달라집니다.인접 행렬의 경우에는 O(|V|^2)을 모두 돌아야 하지만, 인접 리스트의 경우 O(|E| + |V|)가 됩니다. 이는 각 표현에 사용된 모든 값을 참조하기 때문인데, 인접 행렬의 공간복잡도는 O(|V|^2)이며 인접 리스트의 공간복잡도는 O(|E|)입니다.따라서 각 정점 간의 연결관계 참조가 잦다면 인접 행렬 표현이, 순회가 잦거나 |V|가 큰 그래프에서는 인접 리스트의 표현이 유리합니다. 아래는 인접 행렬로 표현된 그래프를 입력받아 이를 인접 리스트로 변환하는 코드입니다. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#define MAX 55using namespace std;int main() &#123; int adj_matrix[MAX][MAX], n; cin &gt;&gt; n; vector &lt; list &lt; int &gt; &gt; head(n + 1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; adj_matrix[i][j]; if (adj_matrix[i][j]) head[i].push_front(j); &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; i &lt;&lt; \" : \"; if (!head[i].empty()) for (auto x : head[i]) cout &lt;&lt; x &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://yoursite.com/tags/자료구조/"}]},{"title":"자료구조_Stack(스택)","slug":"Computer-Science-Data-Structure-20190211-Stack","date":"2019-02-11T01:35:08.000Z","updated":"2019-02-11T04:11:43.429Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-Stack/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-Stack/","excerpt":"","text":"STACK(스택)스택은 선형 구조이며, 마지막으로 삽입된 값이 가장 먼저 나오는 LIFO(Last in First Out)으로 되어 있습니다. 이 때 삽입하는 과정을 push라고 하며 값을 빼내는 과정을 pop이라고 합니다. 예를 들면 a, b, c 순서로 push하고 스택에 있는 값들을 모두 pop하면 c, b, a 순서로 나오게 되는 것입니다. 또한 스택에는 size, top, empty라는 함수가 있으며 size는 스택에 들어있는 값들의 수를 반환하는 함수이고, top은 마지막으로 삽입된 값을 반환하는 함수, empty는 스택이 비어 있는지 여부를 반환하는 함수입니다. 아래의 두 그림은 stack의 push, pop 과정을 보여주는 그림입니다. 그리고 이러한 스택을 만드는 방법에는 2가지 방법이 있습니다. 하나는 배열을 이용한 방법이고, 다른 하나는 링크드 리스트를 이용한 방법입니다. 1) 배열을 이용한 방법에서는 삽입될 위치인 스택의 마지막 부분을 저장하는 변수 top이 필요합니다. 이 변수를 이용하여 스택의 크기(스택에 들어있는 요소의 수)를 빠르게 알 수 있습니다. 또한 스택의 크기가 0일 경우 스택이 비어 있는 것이므로 비어 있는지 여부도 쉽게 알 수 있습니다. 따라서 배열로 구현하기 위해서는 값들을 담을 배열과 스택의 마지막 위치(삽입될 위치)를 저장하는 변수가 필요합니다. 배열로 구현한 스택의 push 와 pop 과정2) 링크드 리스트를 이용한 방법에서는 값과 다음 노드의 위치를 저장하는 스택 노드들을 이용할 것이며 마지막으로 삽입된 노드의 위치를 저장하는 노드형 포인터 top과 노드들의 수를 저장하는 변수 size가 필요합니다. Head 초기화 시 처음에 널 값을 넣어주고, push할 경우 새로 삽입되는 노드의 next가 이전의 top이 되고, NewNode가 top이 됩니다. 링크드 리스트로 구현한 스택의 push 와 pop 과정","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://yoursite.com/tags/자료구조/"}]},{"title":"자료구조_Queue(큐)","slug":"Computer-Science-Data-Structure-20190211-Queue","date":"2019-02-11T01:34:47.000Z","updated":"2019-02-11T04:11:08.118Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-Queue/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-Queue/","excerpt":"","text":"QUEUE(큐)큐는 선형 구조이며, 삽입된 순서대로 값이 나오는 FIFO(First in First Out)로 되어 있습니다. 이때 삽입하는 과정을 enqueue라고 하며 값을 빼내는 과정을 dequeue라고 합니다.예를 들면 a, b, c 순서로 enqueue하고 큐에 있는 값들을 모두 dequeue하면 a, b, c 순서로 나오게 됩니다.또한 큐에는 size, front, empty라는 함수가 있으며 size는 큐에 들어있는 값들의 수를 반환하는 함수이고, front은 큐에서 가장 먼저 삽입된 값을 반환하는 함수, empty는 큐가 비어 있는지 여부를 반환하는 함수입니다. 그리고 이러한 큐를 만드는 방법에는 2가지 방법이 있습니다. 하나는 배열을 이용한 방법이고, 다른 하나는 링크드 리스트를 이용한 방법입니다. 1) 배열을 이용한 방법에서는 삽입될 위치인 큐의 마지막 부분을 저장하는 변수 rear와 큐의 처음 부분을 저장하는 변수 front가 필요합니다. 또한 큐의 데이터 개수를 저장하는 변수 size를 이용하여 큐의 크기(큐에 들어있는 요소의 수)를 빠르게 알 수 있습니다. 또한 큐의 크기가 0일 경우 큐가 비어 있는 것이므로 비어 있는지 여부도 쉽게 알 수 있습니다. 따라서 배열로 구현하기 위해서는 값들을 담을 배열과 큐의 처음 위치와 마지막 위치(삽입될 위치)를 저장하는 변수가 필요합니다. 또한 enqueue과정과 dequeue과정에서 각각 rear index, front index가 점점 뒤로 밀려나기 때문에 이를 효율적으로 구성하려면 환형 배열로 구현해주어야 합니다. 2) 링크드 리스트를 이용한 방법에서는 값과 다음 노드의 위치를 저장하는 큐 노드들을 이용할 것이며 마지막으로 삽입된 노드의 위치를 저장하는 노드형 포인터 rear와 큐의 가장 앞 노드의 위치를 저장하는 노드형 포인터 front, 노드들의 수를 저장하는 변수 size가 필요합니다. front와 rear는 초기화시 처음에 널 값을 넣어주고, enqueue할 경우 이전에 rear의 next는 새로 삽입하는 노드가 되고, 새로 삽입되는 노드가 rear가 됩니다. dequeue할 경우 이전의 Head의 next가 Head가 되고, 이전의 head는 메모리 할당 해제 시킵니다.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://yoursite.com/tags/자료구조/"}]},{"title":"자료구조_List(연결리스트)","slug":"Computer-Science-Data-Structure-20190211-List","date":"2019-02-11T00:36:51.000Z","updated":"2019-02-11T04:14:59.884Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-List/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-List/","excerpt":"","text":"LIST(연결리스트)연결리스트는 랜덤 접근이 가능한 배열과는 다른 순차적인(sequential) 자료구조입니다.연결리스트는 노드들로 구성되어 있습니다. 노드는 저장할 값과 다음 노드를 가리키는 포인터로 이루어져 있습니다. 연결리스트의 첫 노드인 헤드(Head)로 부터 노드에 다음 노드를 가리키는 포인터를 사용해 리스트를 순회할 수 있게 됩니다. 위와 같은 연결리스트를 Singly Linked List라고 합니다. Singly Linked List의 각 노드에 이전 노드를 가리키는 포인터를 추가하게 되면 양방향으로 순회가 가능한 Doubly Linked List가 되고, 환형 큐(Circular Queue)와 같이 연결리스트의 마지막 노드인 테일(Tail)과 헤드를 이으면 Circular Linked List가 됩니다.이는 문제의 상황에 따라 구현하여 사용하시면 됩니다. 각 노드는 저장할 값과 자신의 앞, 뒤 노드를 가르키는 포인터를 가짐테일의 포인터는 헤드를 가르킴 두 자료구조의 장단점을 나열해보자면, 배열은 인덱스로 인한 무작위 접근이 가능하고, 리스트에 비해 저장공간을 적게 필요로 하지만, 리스트에 비해 자료의 삽입, 삭제가 비효율 적인 부분이 있습니다. 순서를 유지하면서 자료를 삽입 / 삭제하기 위해서는 최악의 경우 모든 데이터를 옮겨주어야 하기 때문입니다. 리스트는 무작위 접근이 불가능하므로 무조건 순차적으로 탐색해야 하며, 노드에 저장할 값과 포인터를 포함하고 있기 때문에 똑같은 크기의 배열에 비해 저장공간을 많이 차지하게 되지만, 자료의 삽입과 삭제가 새로운 노드를 만들어 포인터로 이어주기만 하면 되기 때문에 간편하고 유연하게 동작합니다. – List(연결리스트) 동적배열 Indexing O(N) O(1) Insert / Delete at beginning O(1) O(N) Insert / Delete at end O(1) when last element is known;O(N) when last element is unknown O(1) Insert / Delete in middle search time + O(1) O(N) 리스트와 배열의 시간복잡도 비교,https://en.wikipedia.org/wiki/Linked_list","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://yoursite.com/tags/자료구조/"}]},{"title":"pyhtonPost","slug":"Python-20190211-pyhtonPost","date":"2019-02-10T15:15:05.000Z","updated":"2019-02-10T15:15:19.246Z","comments":true,"path":"2019/02/11/Python-20190211-pyhtonPost/","link":"","permalink":"http://yoursite.com/2019/02/11/Python-20190211-pyhtonPost/","excerpt":"","text":"","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[]},{"title":"Algorithm problem solving List","slug":"Algorithm-20190210-algorithmPost","date":"2019-02-10T14:53:11.000Z","updated":"2019-02-11T08:10:03.860Z","comments":true,"path":"2019/02/10/Algorithm-20190210-algorithmPost/","link":"","permalink":"http://yoursite.com/2019/02/10/Algorithm-20190210-algorithmPost/","excerpt":"","text":"알고리즘 문제 해결 리스트 사이트 업적 Project Euler 40문제 codeground Lv.14 programmers 1193점 Topcoder-Arena Green Baekjoon Online Judge 16문제 해결 그외 자잘하게 푼 사이트는 제외했습니다. Project Euler내가 컴퓨터공학과 1학년을 마치고 군 입대를 하고 어느정도 여유가 생겼을때 부터 시작하게된 알고리즘 사이트입니다. 프로젝트 오일러는 수학적인 문제들을 컴퓨터 프로그래밍으로 해결하는 사이트입니다. 의미있었고, 어려웠던 문제 10개 선정- [10번] Summation of primes 이백만(2,000,000) 이하 소수의 합은 얼마일까 문제이다. 그때 당시 내가 할수 있는 것은 소수판별 식을 세우고 이백만까지 돌리는 것이다. 당시에는 그것이 대단한것이라고 생각해 두근거리면서 기다리니 답이나왔다. 나중에 에라토스테네스의 체를 알게되고 한동안 에라토스테네스의 체에 빠져살면서 소수에 관해서 연구 했습니다. - [19번] Counting Sundays 20세기 (1901년 1월 1일 ~ 2000년 12월 31일) 에서, 매월 1일이 일요일인 경우는 총 몇 번입니까? 군대에서 당직서면서 종이와 펜으로 손코딩으로 풀던문제였다.기준으로 잡는 날짜와 윤년의 경우를 if문 한줄로 표현하려고 끙끙 앓았었다. 당시에는 모든 날짜에 대해서 검사했는데 해당 월이 몇일 까지 있는지 계속 더해서 mod 7 연산으로 쉽게 파악할수 있었습니다. - [24번] Lexicographic permutations 0, 1, 2, 3, 4, 5, 6, 7, 8, 9로 만들 수 있는 사전식 순열에서 1,000,000번째는 무엇입니까? 지금 풀었다면 길어도 30분안에는 풀수있는 문제였지만 당시에는 순열 알고리즘과 사전식 정렬을 할 줄 몰랐지만 나름 규칙을 찾아서 코딩으로 옮겨내서 풀수있었습니다. - [29번] Distinct powers 2 ≤ a ≤ 100 이고 2 ≤ b ≤ 100인 a, b를 가지고 만들 수 있는 ab는 중복을 제외하면 모두 몇 개입니까? - [50번] Consecutive prime sum 1백만 이하에서는 어떤 소수가 가장 길게 연속되는 소수의 합으로 표현될 수 있습니까? - [52번] Permuted multiples 2배, 3배, 4배, 5배, 6배의 결과도 같은 숫자로 이루어지는 가장 작은 수는 무엇입니까? - [67번] Maximum path sum II 삼각형 꼭대기에서 인접한 숫자를 찾아 내려가면서 가장 큰 합이되는 경로는? - [97번] Large non-Mersenne prime 28433×2^7830457+1 이소수의 마지막 10자리는 얼마입니까? - [113번] Non-bouncy numbers 오락가락수가 아닌 수 - [119번] Digit power sum 자릿수 합의 거듭제곱 codeground삼성에서 만든 programmers코딩테스트 운영 Topcoder-Arena생애 첫 알고리즘 대회 참가 Baekjoon Online Judge최대 문제 보유, 문제은행. 알고리즘 문제 해결 능력 테스트에 대해서..어느 순간부터 알고리즘 문제 해결 능력이 지원자들을 평가하는 요소가 되었습니다.객관적이고 순위를 매길 수 있기 때문에 평가에 불만이 없고, 어느 정도 코딩역량을 알아볼수 있다고 생각합니다.내가 처음으로 알고리즘 문제를 접하고 이를 어떤 인터넷 검색도 없이 해결했을 때 성취감은 이로 말할 수 없었고 이를 통해서 좀더 프로그래밍의 세계에 빠져들었던것 같습니다. 하지만 이제는 거의 모든 기업에서 앞서 코딩테스트를 필수화 시켰고, 다수가 코딩테스트에서 높은 점수를 받기위해서 문제푸는 연습을 하며 알고리즘 문제 해결을 즐기지 못하고 있다고 생각도 듭니다.. 지금에는 알고리즘 문제를 인터넷에 검색하면 해당 문제에 대한 해결법을 얻을 수 있게 되었습니다. 마치 답지를 옆에 가져다 두고 학습지를 풀며 문제 유형을 익히는데 집중하던 주입식 교육을 하게될 지도 모릅니다.한문제 한문제 꾸역꾸역 풀어가며, 인터넷에 떠도는 해답지 보다 훨씬 빠르고 효율적인 알고리즘을 만들 수 있다는 것을 우리는 항상 생각해야 될것입니다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"ps","slug":"ps","permalink":"http://yoursite.com/tags/ps/"}]},{"title":"stockPost","slug":"Stock-20190210-stockPost","date":"2019-02-10T13:31:53.000Z","updated":"2019-02-10T14:52:56.947Z","comments":true,"path":"2019/02/10/Stock-20190210-stockPost/","link":"","permalink":"http://yoursite.com/2019/02/10/Stock-20190210-stockPost/","excerpt":"","text":"","categories":[{"name":"Stock","slug":"Stock","permalink":"http://yoursite.com/categories/Stock/"}],"tags":[]},{"title":"dataSciencePost","slug":"Data-Science-20190210-dataSciencePost","date":"2019-02-10T13:30:33.000Z","updated":"2019-02-10T14:52:42.258Z","comments":true,"path":"2019/02/10/Data-Science-20190210-dataSciencePost/","link":"","permalink":"http://yoursite.com/2019/02/10/Data-Science-20190210-dataSciencePost/","excerpt":"","text":"","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://yoursite.com/categories/Data-Science/"}],"tags":[]},{"title":"Hell..","slug":"Blog-20190210-Hell","date":"2019-02-10T12:42:25.000Z","updated":"2019-02-10T14:52:02.691Z","comments":true,"path":"2019/02/10/Blog-20190210-Hell/","link":"","permalink":"http://yoursite.com/2019/02/10/Blog-20190210-Hell/","excerpt":"","text":"ㅎㅇ","categories":[{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/categories/Blog/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-02-09T19:05:45.592Z","updated":"2019-02-09T19:05:45.592Z","comments":true,"path":"2019/02/10/hello-world/","link":"","permalink":"http://yoursite.com/2019/02/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}