{"meta":{"title":"Hanson|개발자","subtitle":"승한 개발 블로그","description":"알고리즘 문제, 수학, 최적화 문제에 흥미를 가지며 금융, 분석 개발자로 나아가는 블로그입니다.","author":"son seung Han","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-02-10T11:29:50.000Z","updated":"2019-02-12T02:32:56.602Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Introduce 끝날 때까지는 끝난 게 아니다. 꾸준한 것이 최고라고 생각하는 개발자 손승한입니다. 알고리즘 , 수학, 최적화 문제에 흥미를 가지고 금융 및 분석 개발자로 나아가고 있습니다. 더불어 새로운 사람들과 어울리는 것을 좋아하며, 사람들과 다양한 주제로 토론하는 것을 좋아합니다. Language C, C++, Python, Java, Javascript Skills C / C++ / Python / Java / Javascript / jQuery MySQL / Oracle / MSSQL algorithm problem solving AWS(EC2, RDS, S3) / NCloud(server, cloud DB) UbuntuOS / CentOS / macOS Git / Github / SVN R / dataAnalysis PyCham / VSCode / Sourcetree / TortoiseSVN Slack / Trello / githubBlog Stock investment REST API Studing RESTful API R / dataAnalysis Python OOP -&gt; SOLID TDD Design pattern NOSQL -&gt; Redis 수상 및 활동 기간 “제4회 K해커톤 앱개발챌린지(사)앱센터 - 우수상” 2016.10 “에너지 ICT 분야 소프트웨어 경진대회(주)한전KDN - 우수상” 2016.12 “한국지능시스템학회 춘계학술대회우수논문상” 2017.4 목포대학교 멋쟁이사자처럼 동아리 개설 및 운영초대 동아리 회장 2017.1 - 2017.12 링크github - repositoriesgithub - 기술블로그tistory - 티스토리블로그"}],"posts":[{"title":"Basic statistics(기초통계) 정리","slug":"Data-Science-20190212-BasicStatistics","date":"2019-02-12T00:35:30.000Z","updated":"2019-02-12T01:10:05.193Z","comments":true,"path":"2019/02/12/Data-Science-20190212-BasicStatistics/","link":"","permalink":"http://yoursite.com/2019/02/12/Data-Science-20190212-BasicStatistics/","excerpt":"","text":"기초 통계 정리키워드 목차1) 기술통계와 추리통계2) 모집단과 표본3) 척도4) 도수분포표와 그래프5) 공분산과 상관계수6) 가설과 신뢰수준/유의확률7) 양측 검증과 단측 검증8) t-분석9) 분산분석10) 회귀분석11) 로직스틱 회귀분석12) 조절효과와 매개효과13) 구조 방정식 모형14) 다수준분석 [기초통계]01_기술통계와 추리통계기술통계 수집한 자료를 분석하여 대상들의 속성을 파악하는 통계방법1) 중심경향값 : 전체 자룔르 대표할 수 있는 수치들○ 평균 : 전체 자료가 가지는 수치들의 총합을 전체 자료의 수로 나눈 수치○ 중앙값 : 최대값과 최소값의 정가운데 수치○ 최빈값 : 가장 많은 빈도를 보이는 수치2) 분산도 : 전체 자료가 얼마나 퍼져 있는 지를 알 수 있는 수치들○ 분산 : 각 자료가 평균으로 부터 떨어진 거리(편차)들을 제곱한 수치들의 총합을 전체 자료로 나눈 수치○ 표준편차 : 분산을 제곱근을 취한 수치3) 상관계수 : 두 변수 간의 관계의 크기4) 회귀계수 : 독립변수(원인)가 종속변수(결과)에 미치는 영향의 크기 추리통계(추론통계) 모집단을 대표하는 표본을 추출하고 표본의 기술통계를 이용하여 모집단의 속성들을 유추하는 통계방법 신뢰구간 추리통계에서 예측한 모집단의 특성이 위치할 가능성이 높은 구간 표본에서 구해지는 기술통계값들을 이용하여 계산되며, 95%, 99%, 99.9% 신뢰수준에서 따라 달라짐95% 신뢰구간보다 99% 신뢰구간 영역이 더 덟음 [기초통계]02_모집단과 표본모집단 연구 또는 분석이 이루어지는 전체 대상○ 모집단에서 추출한 표본집단표본 모집단에서 추출한 일부로, 모집단의 속성들을 유추하는데 사용a. 확률표본추출 방법 : 무작위로 표본을 추출하는 방법으로 모집단을 대표할 가능성이 높은 방법b. 비확률표본추출방법 : 조사자의 편의나 판단에 의해서 표본을 추출하는 방법을 ㅗ모집단을 대표하지 않을 가능성이 존재하는 방법 중심극한정리 표본이 30이상으로 충분히 클 때a. 모집단의 분포와 상관없이 표본은 정규분포b. 표본의 평균 = 모집단의 평균c. 표본의 분산 = (모집단의 분산) / (표본의 수) 자유도 평균을 유지하면서 자유롭게 어떠한 값도 가질 수 있는 사례의 수자유도는 표본에서 1을 차감한 수치 [기초통계]03_척도척도 포괄성 : 척도 안에 모든 경우의 수가 포함되어야 한다는 원칙 상호배타성 : 척도 안에 중복되는 경우의 수가 없어야 한다는 원칙 명목척도 측정이 이루어지는 항목들이 상호배타적인 특성만을 가진 척도○ 당신의 성별은? 서열척도 명목척도들 중 항목들 간에 서열이나 순위가 존재하는 척도○ 당신의 최종 학력은? 등간척도 서열척도들 중 항목들 간의 간격이 일정한 척도○ 당신의 직무에 대해 얼마나 만족하십니까? 비율척도 등간척도 중 아무 것도 없는 상태를 0으로 정할 수 있는 척도 [기초통계]04_도수분포표와 막대그래프도수분포표 수집된 자료를 쉽게 이해할 수 있도록 일목요연하게 정리된 표로, 특정 항목 또는 특정 범위에 속하는 빈도수를 나타낸 표 막대그래프 비연속형 변수(명목척도 및 서열척도)에 사용되는 그래프로, 각항목에 속하는 빈도수를 나타낸 그래프 히스토그램 연속형 변수(등간척도 및 서열척도)에 사용되는 그래프로, 일정 범위에 속하는 빈도수를 나타낸 그래프 선그래프 히스토그램의 끝 부분을 선으로 연결한 그래프 [기초통계]04_도수분포표와 막대그래프도수분포표 수집된 자료를 쉽게 이해할 수 있도록 일목요연하게 정리된 표로, 특정 항목 또는 특정 범위에 속하는 빈도수를 나타낸 표 막대그래프 비연속형 변수(명목척도 및 서열척도)에 사용되는 그래프로, 각항목에 속하는 빈도수를 나타낸 그래프 히스토그램 연속형 변수(등간척도 및 서열척도)에 사용되는 그래프로, 일정 범위에 속하는 빈도수를 나타낸 그래프 선그래프 히스토그램의 끝 부분을 선으로 연결한 그래프 [기초통계]05_공분산과 상관계수공분산 두 변수가 함께 각자의 평균으로부터 멀어지는 정도 한 변수가 자신의 평균으로부터 멀어질 때 다른 변수가 자신의 평균으로 부터 멀어지는 정도를 의미○ cov(A, B) = 상관계수 두 변수 간의 관계로, 하나의 변수가 변화함에 따라 다른 변수가 변화하는 정도를 의미○ r_AB = Cov(A,B) / S_a * S_b -1 에서 1 사이의 범위를 가짐 양의 상관관계, 음의 상관관계, 무의미한 상관관계 [기초통계]06_가설과 신뢰수준영가설(H_0) 연구가설과는 반대되는 가설이고, 실제 분석이 이루어지는 가설 연구가설(H_1) 분석을 통해서 알아보고자 하는 내용으로 이루어진 가설 통계분석에서 영가설(H0)이 채택 시 연구가설을 기각 통계분석에서 영가설(H0)이 기각 시 연구가설을 채택 유의확률 실제로는 영가설이 참(채택)임에도 불구하고 통계분석을 통해 영가설을 거짓(기각)으로 판단할 가능성(p-value) 즉, 연구결과가 실제 현상을 반영하지 못할 가능성 예를 들어, 영가설(H0)로 ‘A집단의 평균과 B집단의 평균 간에는 차이가 없다. ‘ 라고 설정할 경우, 실제 두집단 간에 차이 없음에도 차이가 있다고 결론 내릴 가능성 신뢰수준 실제로는 영가설이 참이고 통계분석을 통해서도 영가성을 참으로 판단할 가능성 즉, 실제 현상에서 발생하지 않은 연구가설을 기각할 가능성 예를 들어, 영가설(H0)로 ‘ A 집단의 평균과 B집단의 평균 간에는 차이가 없다. ‘ 라고 설정할 경우, 실제 두 집단 간에 차이가 없으며, 두 집단의 차이가 없다고 결론 내릴 가능성 신뢰수준이 높아질수록 영가설(H0)이 채택될 가능성이 높아지고, 반대로 연구가설(H1)이 채택될 가능성이 낮아짐 즉, 신뢰수준이 높아질수록 연구가설이 실제 현상을 반영할 가능성이 상승 가설의 판단 기준 95% 신뢰수준 ( 유의확률 0.05 미만 ) : * 99% 신뢰수준 ( 유의확률 0.01 미만 ) : ** 99.9%신뢰수준( 유의확률 0.001미만) : *** 90% 신뢰수준 ( 유의확률 0.1 미만 ) : ✞ [기초통계]07_양측 검증과 단측검증양측 검증 방향성을 고려하지 않은 채로 연구가설(H1)을 설정하는 검증 방법 단측 검증 방향성을 고려하여 연구가설을 설정할 때 사용하는 검증방법 양측검증a. A집단의 평균과 B집단의 평균 간에는 차이가 있을 것이다.b. A변수가 B변수에 미치는영향의 크기는 ‘0’이 아니다 단측검증a. A 집단의 평균보다 B집단의 평균이 클 것이다.(또는 작을 것이다.)b. A변수가 B변수에 미치는 영향의 크기는 ‘0’보다 클것이다.(또는 작을 것이다.) 연구가설(H1)의 채택 가능성 양측 검증 보다는 단측 검증일 경우에 연구가설(H1)이 채택될 가능성이 높다. 95%신뢰수준의 단측검증 = 90% 신뢰수준의 양측검증 [기초통계]08_t-분석t-분석방법 독립변수가 비연속형 변수(즉, 명목척도나 서열척도)이고, 종속변수가 연속형 변수(즉, 등간척도나 비율척도)일 때 사용하는 분석방법으로, 독립변수의 집단이 2개 이하일 때 사용하는 분석방법 t-분포를 사용하여 분석 1) 일표본 t-분석 하나의 모집단에서 표본을 추출할 때 사용되는 분석으로 표본의 평균이 예측한 특정 수치와 같은 지 아니면 다른 지를 검증하는 방법 H0 : 국내 중학생의 평균 키는 170cm이다. H1(양측 검증) : 국내 중학생의 평균 키는 170cm가 아니다. H1(단측 검증) : 국내 중학생의 평균 키는 170cm보다 크다(작다). 2) 독립표본 t-분석 두개의 모집단에서 각각의 표본을 추출할 때 사용되는 분석으로 두 집단의 표본들의 평균이 서로 같은 지 다른 지를 검증하는 방법 H0 : A집단의 평균과 B집단의 평균은 같다. H1 (양측 검증) : A집단의 평균과 B집단의 평균은 다르다. H1 (단측 검증) : A집단의 평균은 B집단의 평균 보다 크다(작다). 3) 대응표본 t-분석 하나의 모집단에서 표본을 추출하지만, 같은 표본에게 두 번의 측적이 이루어질 때 사용 H0 : 사전 수치와 사후 수치는 같다. H1 (양측 검증) : 사전 수치와 사후 수치는 다른다. H1 (단측 검증) : 사전 수치보다 사후 수치가 더 크다(작다). [기초통계]09_분산분석(ANOVA)분산분석 방법 독립변수가 비연속형 변수(즉, 명목척도나 서열척도)이고, 종속변수가 연속형 변수(즉, 등간척도나 비율척도)일 때 사용하는 분석방법으로, 독립변수의 집단이 3개 이상일 때 사용하는 분석방법 F-분포를 사용하여 분석 분산분석 대표 가설 H0 : 집단들의 평균은 모두 같다. H1 : 집단들의 평균은 서로 다르다. 분산분석의 원리 집단 간 분산과 집단 내 분산을 통해 분석○ 집단간 분산 &gt; 집단 내 분산 : 집단간 차이가 있음○ 집단간 분산 &lt; 집단 내 분산 : 집단간 차이가 크지 않음○ 실제 분석은 (집단 간 분산) / (집단 내 분산)을 활용—- 1보다 크면 차이 있음 사후 분석 : 어떠한 집단들 간에 평균 차이가 발생하는 지를 알아보기 위한 분석방법 [기초통계]10_회귀분석회귀분석 방법 독립변수와 종속변수가 모두 연속형 변수(즉, 등간척도나 비율척도)일 때 사용하는 분석방법 추정방식은 OLS(Ordinary least square) 로 이루어지는데, 이는 오차의 제곱을 최소화 하는 직선이라는 의미 회귀분석의 원리 y = b0 + b1 * x + e○ Y : 종속변수 , X : 독립변수, b0 : 절편, b1 : 기울기, e : 오차 대표가설 H0 : 독립변수가 종속변수에 미치는 영향의 크기는 ‘0’이다 H1 (양측 검증) : 독립변수가 종속변수에 미치는 영향의 크기는 ‘0’이 아니다. H1 (단측 검증) : 독립변수가 종속변수에 미치는 영향의 크기는 ‘0’보다 크다(작다). 회귀분석의 특징 회귀분석에서는 여러 개의 독립변수를 포함하는 것이 가능 여러 독리변수들을 표함하는 경우에는 서로 통제되어 자신의 독자적인 영향력으로 계산 y = b0 + b1x1 + b2x2 + b3x3 + b4x4 설명량 (R^2) 독립변수들에 의해서 설명되어지는 종속변수의 분산 R^2가 증가할수록 회귀식에서 설명되어지지 못하는 오차는 감소 증가된 설명량(△R^2)을 이용해서 독립변수의 포함 여부를 결정 [기초통계]11_로지스틱 회귀분석로지스틱 회귀분석 방법 독립변수가 연속형 변수이지만, 종속변수가 변연속형 변수(특히, 이분형변수)인 경우에는 로지스틱 회귀분석을 사용하는 분석방법 로지스틱 회귀분석의 원리 Odd Ratio = p / 1- p=&gt; 특정 사건이 발생할 확률과 발생하지 않을 확률간의 비율 로지스틱 회귀식○ ln(p / 1-p) = b0 + b1 * x =&gt; 회귀분석에서 종속변수(y)를 Odd 비에 자연로그를 취한 값으로 대체 b1 &gt; 0 : x가 증가할수록 특정 사건이 발생하지 않을 확률보다 발생할 확률이 높다는 의미 b1 &lt; 0 : x가 증가할수록 특정 사건이 발생할 확률보다 발생하지 않을 확률이 높다는 의미 로지스틱 회귀분석 대표 가설 H0 : 독립변수가 종속변수에 미치는 영향의 크기는 ‘0’이다. H1 (양측검증) : 독립변수가 종속변수에 미치는 영향의 크기는 ‘0’이 아니다. H1 (단측검증) : 독립변수가 종속변수에 미치는 영향의 크기는 ‘0’ 보다 크다. 모형적합도 모형이 적절하게 만들어졌는 지를 보여주는 지표 로지스틱 회귀분석에서는 모형에 포함된 독립변수들에 의해서 종속변수가 설명되어지는 부분 대표적으로 X^2 - 수치 , -2log 우도 등이 사용 [기초통계]12_조절효과와 매개효과조절효과 독립변수가 종속변수에 미치는 영향이 조절변수에 의해서 달라지는 지를 알아보는 분석방법 매개효과 독립변수와 종속변수 간의 직접적인 인과관계 이외에도 매개변수를 통한 간접적인 인과관계가 존재하는 지를 알아보는 분석방법 총 효과 = 직접효과 + 간접효과 (또는 매개효과) [기초통계]13_구조방정식모형구조방정식모형 변수들 간의 관계를 밝히는 구조모형과 각 변수와 이를 측정하는 문항들 간의 관계를 밝히는 측정모형을 함께 고려하는 분석방법 확인적 요인분석과 매개효과 분석에 주로 활용 확인적 요인분석 확인적 요인분석은 측정문항들의 타당도를 알아보기 위한 분석으로 구조방정식모형 중 측정모형만을 분석하는 방법 [기초통계]14_다수준분석단일수준분석 모든 변수가 하나의 수준으로 이루어진 경우 다수준분석 독립변수와 종속변수의 수준이 다른 경우 독립변수와 종속변수의 개인수준이지만 조절변수의 수준이 다른 경우","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://yoursite.com/categories/Data-Science/"}],"tags":[{"name":"기초통계","slug":"기초통계","permalink":"http://yoursite.com/tags/기초통계/"}]},{"title":"Sieve of Eratosthenes(에라토스테네스의 체)","slug":"Algorithm-BasicAlgorithm-20190211-SieveofEratosthenes","date":"2019-02-11T04:40:17.000Z","updated":"2019-02-11T04:50:50.987Z","comments":true,"path":"2019/02/11/Algorithm-BasicAlgorithm-20190211-SieveofEratosthenes/","link":"","permalink":"http://yoursite.com/2019/02/11/Algorithm-BasicAlgorithm-20190211-SieveofEratosthenes/","excerpt":"","text":"Sieve of Eratosthenes에라토스테네스의 체는 특정 범위의 수들이 소수(Prime)인지 아닌지를 판별하는 알고리즘입니다. 에라토스테네스의 체의 원리는 간단합니다.1~50까지 모든 소수를 구하고자 한다면, 먼저 아래와 같은 배열이 필요합니다. 이 배열은 해당 인덱스의 숫자가 소수인지 아닌지를 나타냅니다. 먼저 가장 작은 소수 2부터 시작합니다. 그리고 2의 배수에 해당하는 수들은 모두 소수가 아닙니다. 따라서 범위 안의 2의 배수들을 소수가 아니라고 체크해줍니다.(일반적으로 boolean타입이나 int형 변수를 만들어주어 체크) 아래에서 색이 칠해진 수는 소수가 아님을 나타냅니다. 다음은 3입니다. 3은 2의 배수가 아니므로 체크가 되어있지 않습니다. 따라서 3은 소수입니다. 아까 했던 방식처럼 범위 안의 3의 배수를 모두 소수가 아니라고 체크해줍니다. 다음은 4입니다. 4는 2의 배수를 체크할 때 체크된 숫자이므로 소수가 아닙니다. 따라서 그냥 넘어갑니다. 그러면 다음 수는 5입니다. 5는 체크된 숫자가 아니므로 소수입니다. 마찬가지로 5의 배수를 모두 체크 해줍니다. 다음 수인 6은 4와 마찬가지로 색이 칠해져 있습니다. 즉 6은 이미 어떤 소수의 배수였기 때문에 소수가 아니라는 것을 알 수 있습니다. 따라서 2부터 시작해서 구하고 싶은 최대값까지 차례대로 보며 남은 수 중 아직 지워지지 않은 가장 작은 값은 소수가 되며, 이 배수들을 지워나가면 우리는 범위 내의 모든 소수를 구할 수 있습니다.위의 과정을 50까지 반복하면 배열은 아래와 같이 변하고, 이때 칠해지지 않은 수 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47이 1 ~ 50 범위에 속하는 소수가 됩니다. 위와 같은 방식으로 아주 작은 소수부터 시작해서 해당 수들의 배수를 제외시켜 나가는 알고리즘을 에라토스테네스의 체라고 합니다. 이를 수도코드로 나타내면 다음과 같습니다. 123456789Boolean Array isPrime[N]=&#123;true, …,true&#125;For(i=2;i&lt;=N;i++)&#123; If(isPrime[i] is false) continue For(j=i+i;j&lt;=N;j+=i) &#123; isPrime[j]=false &#125;&#125; 위의 코드는 최적화가 가능합니다. 첫 번째 반복문의 범위를 1부터 N까지가 아닌 1부터 sqrt(N)까지라고 한다면 정확성은 유지하면서 속도가 좀 더 빨라집니다. 어째서 N이 아닌 sqrt(N)까지로 하는지 의문이 들 수 있으므로 추가 설명하겠습니다.제곱인 숫자 A가 있다고 가정합시다. 어떤 수 A의 약수의 개수는 홀수 개 입니다 (만약 이 수가 어떤 수의 제곱이 아니라면 짝수 개가 되겠죠). 그리고 A의 전체 약수 집합이 {a1, a2, a3, a4, a5, a6, a7, a8}이었다고 한다면 이는 A = a1a8 = a2a7 = a3a6 = a4a5로 나타낸 수 있습니다.즉, 어떤 수 N을 약수로 나눈 몫 또한 약수가 되게 됩니다. 따라서 해당 수가 어떤 수의 제곱이라면 왼쪽 그림과 같이 표현할 수 있고, 아니라면 오른쪽 그림과 같이 표현할 수 있습니다.그러면 A의 약수를 구할 때 1부터 A까지가 아닌 1부터 sqrt(A)까지 구해야 된다는 것은 자명합니다. 따라서 N이 소수인지 아닌지 확인하기 위해 N 까지 확인하면 N의 약수들의 배수들이 소수인지 판별되었다는 것 또한 자명하기 때문에 이 알고리즘은 위와 같이 최적화가 가능합니다. 123456789Boolean Array isPrime[N]=&#123;true, …,true&#125;For(i=2;i&lt;= sqrt(N);i++)&#123; If(isPrime[i] is false) continue For(j=i+i;j&lt;=N;j+=i) &#123; isPrime[j]=false &#125;&#125; 하지만 해당 범위 내에서 M번째 소수를 구하는 문제라면 위와 같이 최적화 해선 안됩니다. 위와 같이 최적화하고 범위 내의 소수를 구한다면 sqrt(N)까지 범위의 소수들만 구해지기 때문입니다. 따라서 해당 숫자가 소수인지 아닌지 판별할 경우에는 위와 같이 최적화하고 해당 소수를 출력하는 문제라면 최적화하지 않고 N까지 돌려야 합니다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"BasicAlgorithm","slug":"Algorithm/BasicAlgorithm","permalink":"http://yoursite.com/categories/Algorithm/BasicAlgorithm/"}],"tags":[]},{"title":"자료구조_Hash(해쉬)","slug":"Computer-Science-Data-Structure-20190211-Hash","date":"2019-02-11T01:35:32.000Z","updated":"2019-02-11T04:11:27.889Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-Hash/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-Hash/","excerpt":"","text":"HASHING해싱은 임의의 길이의 데이터(키, Key)를 고정된 길이의 데이터(해시값, Hash value)로 변환해 작은 크기의 해시 테이블로 대응(Mapping)시켜 식별하는 하나의 기법입니다. 해시 테이블은 M개의 버킷으로 이루어져 있으며, 이 글에서 다루는 해시값은 해당 키가 저장될 버킷의 번호(해시 테이블의 인덱스)를 나타냅니다. 키에서 해시값을 추출하는 일련의 과정을 해시 함수(Hash function)라고 합니다. 해시 함수는 같은 키에 대해서는 동일한 해시값을, 다른 키에 대해서는 다른 해시값을 추출해야 합니다. 하지만 일반적으로 해싱에서 해시값의 범위(M)는 키의 범위보다 작기 때문에 어떤 이상적인 해시 함수라도 비둘기집의 원리에 의해 서로 다른 두 키가 같은 해시값을 가질 수 있습니다. 이런 경우를 충돌(Collision)이라고 합니다. 해싱이 사용되는 예로 문자열(Key)을 정숫값(Hash value)으로 치환하여 문제를 해결하는 방법이 있습니다. 이에 사용되는 가장 대표적인 해시 함수는 진법을 이용하는 것입니다. “SCPC”이라는 단어가 있다고 하면, 아래와 같이 진법을 이용한 해시 함수를 만들 수 있습니다. f(key) = ((((key[0]) 26 + key[1]) 26 + key[2])) * 26 … key[l – 1])f(“SCPC”) = 19 26^3 + 3 26^2 + 16 26^1 + 3 26^0 = 336391 해시 함수의 시간 복잡도를 O(H)라고 할 때 해시값의 중복이 없는 이상적인 해싱에서 키의 검색, 삽입, 삭제에는 모두 O(H)의 시간이 걸립니다.하지만 앞서 말했듯 해시값의 범위가 키의 범위보다 작을 때에는 충돌이 발생할 수밖에 없습니다.예를 들어 위와 같은 진법 변환을 해시 함수로 사용할 때에는 문자열이 길어지면 해시값이 너무 커지므로 적당히 큰 수로 나머지 연산한 값, 이 글에서는 해시 테이블의 크기 M으로 나머지 연산한 값을 해시값으로 쓸 수 있습니다.이때 해시값의 M에 대한 나머지가 같은 키끼리는 충돌이 발생합니다. 해시 함수와 마찬가지로 충돌을 제어하는 방법도 다양합니다. 여기에서는 대표적인 충돌 제어 방법 중 하나인 체이닝(Chaining)에 대해서 설명하겠습니다.체이닝은 충돌한 키들을 보존하기 위해 각 버킷을 리스트 형태로 구현합니다. 최초의 버킷은 모두 원소가 0개인 리스트의 헤더이며, 해당 버킷에 데이터가 추가될 때마다 노드를 추가합니다.이때 어떤 키가 해시 테이블에 존재하는지 검사하기 위해서는 해당 키의 해시값에 해당하는 버킷이 가진 노드를 모두 순회해야 합니다.이는 리스트에서 원소를 찾는 연산과 동일하며 이에 기반한 삭제 연산도 같은 선형 시간이 걸립니다.이때 몇 개의 버킷에만 데이터가 편중되는 최악의 경우 각 연산의 시간 복잡도는 O(H + N)이 됩니다. 이런 상황을 최소한으로 하기 위해서는 해시값의 추출 과정, 즉 해시 함수를 어떻게 구성할 것인지가 핵심이 됩니다.좋은 해시 함수란 해시값을 추출하는 연산이 빠르되 충돌이 적고 해시 테이블의 영역을 고르게 사용할 수 있어야 합니다.예를 들어 위에서 다룬 A * pow(B) mod M 형태의 진법 변환을 사용할 때 A의 값을 0이 아닌 1부터 시작하는 것이 좋습니다.0을 사용하게 되면 “A”와 “AAA”의 해시값이 같아지기 때문입니다. 또한 B와 M이 서로소인 것이 충돌 확률이 낮아 더 좋은 해시 함수가 될 수 있습니다. 해시 함수의 구현과 충돌 제어 방법, 좋은 해시 함수의 조건에 관해서는 굉장히 많은 자료가 있으므로 보다 깊은 이해를 위해 직접 찾아보시기 바랍니다. 글의 첫 부분에서 말했듯 해싱의 핵심은 값의 식별입니다. 그렇기에 원소의 중복을 허용하지 않는 Set이나 Key:Value쌍에서 중복된 Key가 존재하면 안 되는 Map과 같은 자료구조를 구현하는 데에 사용되기도 합니다. 아래는 C언어로 빡세게 해싱을 사용해 set을 구현한 코드입니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define BUCKET_COUNT 10007#define MAX_STRING_LENGTH 100typedef struct node &#123; struct node* next; int hash_value;&#125; node;int get_hash_value(char* key) &#123; int value = 0, len = strlen(key); for(int i = 0; i &lt; len; i++) value = (value * 27 + key[i] - 'A' + 1) % MAX_STRING_LENGTH; return value;&#125;void insert(node** head, char* key) &#123; int hash_value = get_hash_value(key); for(node* current_node = (*head)-&gt;next; current_node-&gt;next != NULL; current_node = current_node-&gt;next) &#123; if(current_node-&gt;hash_value == hash_value) &#123; return ; &#125; &#125; node* new_node = (node *)malloc(sizeof(node)); new_node-&gt;hash_value = hash_value; if (!(*head)) &#123; new_node-&gt;next = NULL; (*head) = new_node; &#125; else &#123; new_node-&gt;next = (*head); (*head) = new_node; &#125; return;&#125;void erase(node** head, char* key) &#123; int hash_value = get_hash_value(key); for(node* precedent_node = *head; precedent_node-&gt;next != NULL; precedent_node = precedent_node-&gt;next) &#123; if(precedent_node-&gt;next-&gt;hash_value == hash_value) &#123; precedent_node-&gt;next = precedent_node-&gt;next-&gt;next; &#125; &#125; return;&#125;int count(node** head, char* key) &#123; int counter = 0; int hash_value = get_hash_value(key); for(node* current_node = (*head)-&gt;next; current_node-&gt;next != NULL; current_node = current_node-&gt;next) &#123; if(current_node-&gt;hash_value == hash_value) &#123; counter++; &#125; &#125; return counter;&#125;int main() &#123; int n; scanf(\"%d\", &amp;n); node* hash[BUCKET_COUNT]; for(int i = 0; i &lt; n; i++) &#123; int command; char key[MAX_STRING_LENGTH + 1]; scanf(\"%d %s\", &amp;command, key); if(command == 1) &#123; insert(hash, key); &#125; else if(command == 2) &#123; erase(hash, key); &#125; else &#123; if(0 &lt; count(hash, key)) &#123; printf(\"1\\n\"); &#125; else &#123; printf(\"0\\n\"); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://yoursite.com/tags/자료구조/"}]},{"title":"자료구조_Heap(힙)","slug":"Computer-Science-Data-Structure-20190211-Heap","date":"2019-02-11T01:35:27.000Z","updated":"2019-02-11T02:44:45.440Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-Heap/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-Heap/","excerpt":"","text":"HEAP(힙)힙(heap) 은 최댓값 또는 최솟값을 빠르게 찾아낼 수 있는 트리형 자료구조입니다.힙은 완전이진트리 형식을 따르며 모든 부모 노드의 값이 자식 노드들의 값과 일정한 대소 관계를 가지게 되는 규칙을 가지고 있습니다.또한 자식노드 사이의 상관관계는 없으므로 유의하여야 합니다.부모 노드의 값이 자식 노드의 값보다 크다면 최대 힙(Max Heap), 부모 노드의 값이 자식 노드의 값보다 작다면 최소 힙(Min Heap) 으로 부릅니다.힙의 규칙에 따라 트리의 가장 상단에는 최댓값 또는 최솟값이 있는 것이 자명하기 때문에, O(1) 만에 최댓값과 최솟값을 찾을 수 있습니다. 힙의 삽입은 트리의 가장 마지막 부분에 데이터를 삽입한 후, 부모 노드와 삽입 부분 노드의 대소 관계를 확인하여 힙의 규칙에 맞도록 부모 노드를 탐색, 스왑하는 과정으로 이루어져 있습니다. 힙의 삭제는 삭제할 원소를 삭제 한 후 트리의 가장 마지막 원소를 삭제된 원소의 위치에 넣어준 후 힙의 조건을 만족하는 적절한 위치에 이를 수 있도록 조정해주면 됩니다. 제일 마지막 원소를 삭제된 원소의 자리로 옮긴다. 힙의 규칙에 맞도록 부모와 자식노드를 바꾸어 준다.삭제가 완료된 힙 힙의 삽입과 삭제의 시간 복잡도는 최악의 경우 최하단 노드로부터 최상단 노드까지 스왑이 필요하게 됩니다. 따라서 O(log N)의 시간 복잡도를 가집니다. 완전이진트리를 사용하기 때문에 최대 사이즈의 배열로 선언 후 쉽게 구현하실 수 있습니다. 다음은 최소 힙을 사용한 오름차순 정렬을 하는 프로그램의 코드입니다. 123456입력첫 번째 줄에 정렬할 원소의 수 N,두 번째 줄에는 정렬해야 할 원소 n개가 입력된다.출력정렬 후의 원소들을 출력한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX 5005using namespace std;int heap[MAX];int main()&#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int m; cin &gt;&gt; m; heap[i] = m; for (int j = i; j &gt; 1; j /= 2) &#123; if (heap[j] &gt; heap[j / 2]) &#123; swap(heap[j], heap[j / 2]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; swap(heap[1], heap[n - i + 1]); for (int j = 1; ; ) &#123; int k = j * 2; if (k &gt; n - i) break; if (k + 1 &lt;= n - i &amp;&amp; heap[k] &lt; heap[k + 1]) k++; if (heap[j] &lt; heap[k]) &#123; swap(heap[j], heap[k]); j = k; &#125; else break; &#125; &#125; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; heap[i] &lt;&lt; \" \"; return 0;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[]},{"title":"자료구조_Tree(트리)","slug":"Computer-Science-Data-Structure-20190211-Tree","date":"2019-02-11T01:35:23.000Z","updated":"2019-02-11T04:14:56.571Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-Tree/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-Tree/","excerpt":"","text":"TREE(트리)트리는 자식과 부모의 관계로 이루어진 계층적인 구조입니다. 필요에 따라 다양한 종류로 나뉘게 되는데 이번 문서에서는 제일 간단한 트리인 이진 트리에 대해서 설명하려고 합니다. 먼저 이진 트리에서 사용하는 용어들을 정리해보면 다음과 같습니다. 123456789Root : 트리에서 가장 최상위에 존재하는 노드Child : 어떠한 노드의 자식 노드Parent : 어떠한 노드의 부모 노드Siblings : 같은 부모를 갖는 형제 노드Leaf/Terminal : 자식 노드를 갖지 않는 노드Branch/Internal : 자식 노드를 적어도 1개 이상 갖는 노드Degree : 노드가 가지고 있는 자식 노드의 개수Height : 해당 노드부터 Leaf 노드까지의 가장 긴 거리Level : 트리 각 층의 단계 (루트 노드의 경우 1) 위에서 트리에서 사용하는 용어들을 알아보았습니다. 여러분의 이해를 돕기 위해 아래의 그림을 통해서 용어들을 설명하도록 하겠습니다. 1번 노드를 self 현재 노드라고 한다면, 0은 1번 노드의 Parent입니다.( 0은 트리의 최상단에 위치하기 때문에 root 노드입니다). 그리고 3번과 4번 노드는 1의 자식 노드들 입니다. 2번 노드는 1번 노드의 부모인 0번 노드의 자식 노드이므로 sibling입니다.(자매 노드). 또한 자식이 하나도 존재하지 않으면 Leaf/Terminal 노드입니다. 이러한 노드들은 그림에서 연두색으로 표시하였습니다. 만약 자식이 1명이라도 존재한다면 Branch/ Internal 노드입니다. 이러한 노드들은 그림에서 파랑색으로 표현했습니다. 1번 노드의 Degree는 자식 노드의 수인 2입니다. Height는 1번 노드보다 하위 노드들 중 가장 아래에 있는 노드 7번 노드와의 거리인 2입니다. 1번 노드의 level은 2입니다.(루트 노드는 Level이 1) 이제 위에서 정리했던 용어들의 설명이 다 끝났습니다. 다음으로 트리의 탐색 방법에 대해서 설명을 하도록 하겠습니다. 트리 노드들의 값들을 확인하기 위해선 어떤 방법을 사용할까요? 만약 트리가 선형구조로 되어 있다면 그냥 포인터를 하나 두고 한 칸 씩 뒤로 옮기면서 확인하면 되었겠지만 아쉽게도 트리는 비선형 구조입니다. 따라서 일반적인 선형탐색 방법으로는 모든 노드들을 확인할 수 없습니다. 트리에서는 이러한 탐색과정을 Traversal(순회)이라고 합니다. 순회의 방법에는 여러가지가 있지만 대표적으로 사용하는 방법은 3가지가 있습니다. 그 방법은 Pre-Order traversal(전위 순회), In-Order traversal(중위 순회), Post-Order traversal(후위 순회) 입니다. 이 3가지 순회의 차이점은 방문 시 수행할 기능을 어느 시점에 호출하는가 입니다. 먼저 Pre-Order의 수행 방법입니다. (방문 시 수행할 기능은 값 출력이라고 하겠습니다.)1234567891011Pre-Order(현재 트리 노드의 위치 cur)&#123; Print(cur’s value) If(cur’s left exist)&#123; Pre-Order(cur-&gt;left) &#125; If(cur’s right exist)&#123; Pre-Order(cur-&gt;right) &#125;&#125; 두 번째로 In-Order의 수행 방법입니다.1234567891011In-Order(현재 트리 노드의 위치 cur)&#123; If(cur’s left exist)&#123; In-Order(cur-&gt;left) &#125; Print(cur’s value) If(cur’s right exist)&#123; In-Order(cur-&gt;right) &#125;&#125; 마지막으로 Post-Order의 수행 방법입니다.1234567891011Post-Order(현재 트리 노드의 위치 cur)&#123; If(cur’s left exist)&#123; Post-Order(cur-&gt;left) &#125; If(cur’s right exist)&#123; Post-Order(cur-&gt;right) &#125; Print(cur’s value)&#125; 위의 3가지 트리 순회를 보면 Print, 즉 노드를 방문했을 때 수행할 기능의 순서만 변화하는 것을 알 수 있습니다. 그러면 위에서 사용했던 예시인 &lt;그림 1&gt;을 이용하겠습니다. 트리의 순회는 root에서부터 시작합니다. 먼저, Pre-Order(0 : root)을 실행했을 때 출력 결과에 대해서 말씀드리겠습니다. Pre-Order는 자기 자신-왼쪽-오른쪽 순서로 작업을 수행하는 방식입니다.1) 루트인 0번 노드에서 출발하므로 0을 출력합니다. 그리고 왼쪽 노드가 존재하므로 Pre-Order(1)을 호출합니다.2) 1번 노드에서 1을 출력하고 마찬가지로 왼쪽 노드가 존재하므로 Pre-Order(3)을 호출합니다.3) 3번 노드에서 3을 출력하고, 왼쪽 노드가 존재하므로 Pre-Order(7)을 호출합니다.4) 7번 노드에서 7을 출력하게 됩니다. 7번 노드는 왼쪽 노드가 없습니다. 따라서 오른쪽 노드를 확인합니다. 하지만 오른쪽 노드 역시 존재하지 않으므로 Pre-Order(7)은 종료됩니다.5) 다시 Pre-Order(3)으로 돌아갑니다.(재귀 함수) 방금 Pre-Order(3)에서 왼쪽 노드를 확인했기 때문에 오른쪽 노드를 확인합니다. 하지만 오른쪽 노드가 존재하지 않으므로 Pre-Order(3) 역시 종료됩니다.6) Pre-Order(1)로 돌아가게 됩니다. 마찬가지로 왼쪽 노드를 확인했으므로 오른쪽 노드를 확인하는데 4번 노드가 오른쪽 노드이므로, Pre-Order(4)를 호출합니다.7) 4번 노드에서 4가 출력됩니다. 4번 노드도 7번과 같이 Leaf/Terminal 노드이므로 그냥 종료됩니다.8) Pre-Order(1)로 돌아가고 Pre-Order(1)도 종료되어 Pre-Order(0) 으로 돌아갑니다. 이러한 방식으로 방문하게 되면 출력결과는 0-1-3-7-4-2-5-6으로 출력하게 됩니다. 이번에는 In-Order를 실행했을 때 출력 결과에 대해서 말씀드리겠습니다. In-Order는 왼쪽-자기 자신-오른쪽 순서로 작업을 수행하는 방식입니다. 1) 우선 루트인 0번 노드에서 출발합니다. 하지만 Pre-Order와는 다르게 이때 0을 출력하지 않고 왼쪽 자식 노드의 유무를 확인합니다. 이때 왼쪽 노드가 존재하므로 In-Order(1)을 호출합니다.2) 1번 노드에서도 1을 바로 출력하지 않고, 왼쪽 노드가 존재하므로 In-Order(3)을 호출합니다.3) 3번 노드에서도 3에서도 3을 바로 출력하지 않고, 왼쪽 노드가 존재하므로 In-Order(7)을 호출하게 됩니다.4) 7번 노드는 Leaf/Terminal 노드이므로 왼쪽 노드가 없어 7을 출력하고 오른쪽 노드의 유무를 하지만 오른쪽 노드도 없으므로 종료됩니다.5) 다시 In-Order(3)으로 돌아가서 3을 출력하고 오른쪽 노드를 확인하지만 존재하지 않으므로 종료됩니다.6) 다시 In-Order(1)로 돌아가서 1을 출력하고 오른쪽 노드로 4가 존재하므로 In-Order(4)를 호출합니다.7) 4번 노드 역시 Leaf/Terminal 노드이므로 4를 출력하고 종료됩니다.8) 다시 In-Order(1)로 돌아가서 종료되고, In-Order(0)으로 돌아가서 0을 출력합니다. 이러한 방식으로 방문하게 되면 출력값은 7-3-1-4-0-5-2-6이 됩니다. 이것은 x좌표 순으로 정렬했을 때의 순서와 동일합니다. 따라서 자신보다 작은 값은 왼쪽 서브 트리, 큰 값은 오른쪽 서브 트리에 저장하는 이진 탐색 트리라면 In-Order Traversal 방식을 이용했을 때 정렬된 값이 나오게 됩니다. 마지막으로 Post-Order를 설명하겠습니다. 이 방식은 왼쪽-오른쪽-자기자신 순서로 수행하는 방식입니다. 1) 우선 루트인 0번 노드에서 시작하고, 왼쪽 노드가 존재하므로 Post-Order(1)을 호출합니다.2) 1번 노드에서도 왼쪽 노드가 존재하므로 Post-Order(3)을 호출합니다.3) 3번 노드 역시 왼쪽 노드가 존재하므로 Post-Order(7)을 호출합니다.4) 7번 노드는 Leaf/Terminal 노드이므로 7을 출력하고 종료됩니다.5) 다시 Post-Order(3)으로 돌아가서 3번 노드는 오른쪽 노드가 없으므로 3을 출력하고 종료됩니다.6) 1번 노드는 오른쪽 노드가 존재하므로 Post-Order(1)로 돌아가서 오른쪽 노드인 Post-Order(4)을 호출합니다.7) 4번 노드는 Leaf/Terminal 노드이므로 4를 출력하고 종료됩니다.8) 다시 Post-Order(1)로 돌아가서 1을 출력하고 종료됩니다. 이와 같은 방식으로 방문하면 출력값은 7-3-4-1-5-6-2-0이 됩니다. 이러한 트리의 순회 방법들로 트리에서 원하는 값을 탐색할 수 있습니다. 그러면 다음으로는 트리의 삽입에 대해서 알아보도록 하겠습니다. 이진 트리로 설명을 하자면, 각 노드의 왼쪽 오른쪽 노드를 저장하기 위해 아래와 같은 2차원 배열을 만들어줍니다. Child[Node_Num][LR] : Node_Num은 해당 노드의 번호, LR은 0일 경우 왼쪽 자식 노드 1일 경우 오른쪽 자식 노드를 의미합니다. 따라서 0번 노드의 왼쪽 노드가 1번 노드라는 것을 표현하고 싶다면 Child[0][0] = 1과 같이 쓰면 되고, 0번 노드의 오른쪽 노드가 3번 노드라는 것을 표현하고 싶다면 Child[0][1] = 3과 같이 쓰면 됩니다. 그리고 만약 트리 노드마다 값이 존재한다면 1차원 배열인 Value를 만들어주어 각 노드의 값을 표현해주면 됩니다.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://yoursite.com/tags/자료구조/"}]},{"title":"자료구조_Graph(그래프)","slug":"Computer-Science-Data-Structure-20190211-Graph","date":"2019-02-11T01:35:16.000Z","updated":"2019-02-11T04:11:29.842Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-Graph/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-Graph/","excerpt":"","text":"GRAPH그래프란 어떤 상태 혹은 객체 간의 관계를 나타내는 자료구조입니다. 그래프는 정점(Vertex)과 간선(Edge)으로 구성됩니다.정점이란 어떠한 상태 혹은 객체를 나타냅니다. 간선은 그러한 정점 간의 관계, 그중에서도 연결성을 표현하는 요소입니다. 아래 그림은 그래프의 개념이 퍼지기 시작한 ‘쾨니히스베르크의 다리 건너기 문제’의 쾨니히스베르크의 다리를 도식화한 두 그림입니다.A, B, C, D로 나눠진 4개의 구역과 각 구역을 잇는 a, b, c, d, e, f, g 7개의 다리가 있습니다. 왼쪽이 일반적으로 사용되는 그림이며, 이를 그래프 형태로 나타낸 것이 오른쪽의 그림입니다.여기서 원으로 표현된 A, B, C, D가 정점이며 이 정점들을 연결하는 실선 a, b, c, d, e, f, g가 두 지역을 오고 갈 수 있음을 의미하는 간선이 됩니다. 이를 수학적으로 표현하면 아래와 같습니다. 전체그래프 G = (V, E)정점 집합 V(G) = {A, B, C, D}간선 집합 E(G) = {a, b, c, d, e, f, g} 이러한 정점과 간선의 관계를 표현하는 말로 인접(adjacent)과 부속(incident)이 있습니다. 정점 u, v가 있고 이 두 정점을 잇는 간선 e가 있다고 가정합시다. 이때 정점 u, v는 e로 인해 서로 인접합니다. 같은 상황에서 간선 e는 정점 u, v에 부속합니다. 그래프에는 크게 무방향 그래프(undirected graph, 무향 그래프)와 단방향 그래프(directed graph, 유향 그래프)가 있습니다.무방향 그래프란 위의 쾨니히스베르크의 다리와 같이 모든 간선이 양방향으로 연결된 그래프입니다. 정점 u, v에 대해 무방향 그래프에서는 u-&gt;v라면 v-&gt;u이며, u-&gt;v가 불가능하다면 v-&gt;u 역시 불가능합니다.반면 단방향 그래프는 각 간선이 방향을 가집니다. 따라서 정점 u에서 정점 v로 가는 간선 e가 있다면 이는 u-&gt;v를 의미할 뿐, v-&gt;u를 의미하는 것은 아닙니다.단방향 그래프에서 u-&gt;v를 연결하는 간선이 있을 때 u는 v에 인접한다, v는 u로부터 인접하다 라고 표현할 수 있습니다. 간선은 따로 이름을 주지 않더라도 부속한 두 정점으로 표현할 수 있습니다. 무방향 그래프의 경우 u와 v를 연결하는 간선은 (u, v)와 같이 표현합니다. 단방향 그래프의 경우 u에서 나가 v로 들어오는 간선을 로 표현합니다.따라서 위의 무방향 그래프 G1과 단방향 그래프 G2를 아래와 같이 표현할 수 있습니다. G1 = (V, E) V(G1) = {A, B, C} E(G1) = {(A, B), (B, C)} G2 = (V, E) V(G2) = {A, B, C}E(G2) = {&lt;A, B&gt;, &lt;B, C&gt;} 그래프에서 쓰이는 또 다른 개념으로는 차수(degree)가 있습니다. 차수란 각 정점에 부속된 간선의 수로, 무방향 그래프에서 어떤 정점 v의 차수란 v에 부속된 간선의 개수입니다. 단방향 그래프에서 정점의 차수는 입력차수(in-degree)와 출력차수(out-degree)로 나누어집니다. 정점 v의 입력차수는 v로 들어오는 간선의 수이며 출력차수는 v에서 나가는 간선의 수와 같습니다. 이러한 그래프를 코드로 표현하는 데에는 크게 두 가지 방법이 사용됩니다. 첫 번째는 인접 행렬(adjacency matrix)을 이용한 표현입니다. 인접 행렬이란 각 정점이 다른 정점과 연결된 상태에 관한 정보를 나타내는 정사각행렬입니다. 예를 들어, 정점 u에서 나가 정점 v로 들어오는 간선이 있다면 1, 아니면 0으로 인접 행렬을 채웁니다. 무방향 그래프의 경우, u-&gt;v간선이 v-&gt;u 간선과 동일하므로 대각선(diagonal)을 중심으로 대칭(symmetric)됩니다. 아래는 정점이 4개인 단방향 그래프의 예시입니다. 두 번째 방법은 인접 리스트(adjacency list)를 이용한 표현입니다. 인접 리스트란 한 정점과 인접한 정점들을 리스트로 표현하는 형태입니다.아래는 정점이 4개인 단방향 그래프에서 정점 u에서 나가 v로 들어오는 간선들의 정보를 인접 리스트로 나타낸 예시입니다. 그렇다면 두 개의 표현법은 어떻게 다를까요?2차원 인접 행렬의 이름을 adj_matrix, 인접 리스트의 이름을 adj_list라고 할 때 두 표현법은 아래와 같은 장단점을 가집니다.두 정점 u, v가 인접한지를 확인하는 연산을 생각해봅시다. 인접 행렬의 경우 이 연산은 adj_matrix[u][v]의 값을 참조하기만 하면 됩니다. 즉 O(1)의 시간복잡도를 가집니다.하지만 인접 리스트는 adj_list[u]에 연결된 원소들을 순회하며 v가 존재하는지 확인해야 합니다. 최악의 경우 이 연산은 O(|V|)의 시간복잡도를 가집니다.반면 정점 u에 연결된 모든 정점을 탐색하는 상황을 생각해봅시다. 인접 행렬의 경우 어떤 정점들이 연결되어있는지 알기 위해서 모든 adj_matrix[u][i]를 참조해야 합니다. 따라서 O(|V|)의 시간이 걸립니다.하지만 인접 리스트의 경우에는 adj_list[u]에 연결된 정점의 개수만큼만 걸립니다. 물론 최악의 경우 O(|V|)지만 이 탐색이 전체 그래프로 확장된다면 달라집니다.인접 행렬의 경우에는 O(|V|^2)을 모두 돌아야 하지만, 인접 리스트의 경우 O(|E| + |V|)가 됩니다. 이는 각 표현에 사용된 모든 값을 참조하기 때문인데, 인접 행렬의 공간복잡도는 O(|V|^2)이며 인접 리스트의 공간복잡도는 O(|E|)입니다.따라서 각 정점 간의 연결관계 참조가 잦다면 인접 행렬 표현이, 순회가 잦거나 |V|가 큰 그래프에서는 인접 리스트의 표현이 유리합니다. 아래는 인접 행렬로 표현된 그래프를 입력받아 이를 인접 리스트로 변환하는 코드입니다. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#define MAX 55using namespace std;int main() &#123; int adj_matrix[MAX][MAX], n; cin &gt;&gt; n; vector &lt; list &lt; int &gt; &gt; head(n + 1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; adj_matrix[i][j]; if (adj_matrix[i][j]) head[i].push_front(j); &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; i &lt;&lt; \" : \"; if (!head[i].empty()) for (auto x : head[i]) cout &lt;&lt; x &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://yoursite.com/tags/자료구조/"}]},{"title":"자료구조_Stack(스택)","slug":"Computer-Science-Data-Structure-20190211-Stack","date":"2019-02-11T01:35:08.000Z","updated":"2019-02-11T04:11:43.429Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-Stack/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-Stack/","excerpt":"","text":"STACK(스택)스택은 선형 구조이며, 마지막으로 삽입된 값이 가장 먼저 나오는 LIFO(Last in First Out)으로 되어 있습니다. 이 때 삽입하는 과정을 push라고 하며 값을 빼내는 과정을 pop이라고 합니다. 예를 들면 a, b, c 순서로 push하고 스택에 있는 값들을 모두 pop하면 c, b, a 순서로 나오게 되는 것입니다. 또한 스택에는 size, top, empty라는 함수가 있으며 size는 스택에 들어있는 값들의 수를 반환하는 함수이고, top은 마지막으로 삽입된 값을 반환하는 함수, empty는 스택이 비어 있는지 여부를 반환하는 함수입니다. 아래의 두 그림은 stack의 push, pop 과정을 보여주는 그림입니다. 그리고 이러한 스택을 만드는 방법에는 2가지 방법이 있습니다. 하나는 배열을 이용한 방법이고, 다른 하나는 링크드 리스트를 이용한 방법입니다. 1) 배열을 이용한 방법에서는 삽입될 위치인 스택의 마지막 부분을 저장하는 변수 top이 필요합니다. 이 변수를 이용하여 스택의 크기(스택에 들어있는 요소의 수)를 빠르게 알 수 있습니다. 또한 스택의 크기가 0일 경우 스택이 비어 있는 것이므로 비어 있는지 여부도 쉽게 알 수 있습니다. 따라서 배열로 구현하기 위해서는 값들을 담을 배열과 스택의 마지막 위치(삽입될 위치)를 저장하는 변수가 필요합니다. 배열로 구현한 스택의 push 와 pop 과정2) 링크드 리스트를 이용한 방법에서는 값과 다음 노드의 위치를 저장하는 스택 노드들을 이용할 것이며 마지막으로 삽입된 노드의 위치를 저장하는 노드형 포인터 top과 노드들의 수를 저장하는 변수 size가 필요합니다. Head 초기화 시 처음에 널 값을 넣어주고, push할 경우 새로 삽입되는 노드의 next가 이전의 top이 되고, NewNode가 top이 됩니다. 링크드 리스트로 구현한 스택의 push 와 pop 과정","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://yoursite.com/tags/자료구조/"}]},{"title":"자료구조_Queue(큐)","slug":"Computer-Science-Data-Structure-20190211-Queue","date":"2019-02-11T01:34:47.000Z","updated":"2019-02-11T04:11:08.118Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-Queue/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-Queue/","excerpt":"","text":"QUEUE(큐)큐는 선형 구조이며, 삽입된 순서대로 값이 나오는 FIFO(First in First Out)로 되어 있습니다. 이때 삽입하는 과정을 enqueue라고 하며 값을 빼내는 과정을 dequeue라고 합니다.예를 들면 a, b, c 순서로 enqueue하고 큐에 있는 값들을 모두 dequeue하면 a, b, c 순서로 나오게 됩니다.또한 큐에는 size, front, empty라는 함수가 있으며 size는 큐에 들어있는 값들의 수를 반환하는 함수이고, front은 큐에서 가장 먼저 삽입된 값을 반환하는 함수, empty는 큐가 비어 있는지 여부를 반환하는 함수입니다. 그리고 이러한 큐를 만드는 방법에는 2가지 방법이 있습니다. 하나는 배열을 이용한 방법이고, 다른 하나는 링크드 리스트를 이용한 방법입니다. 1) 배열을 이용한 방법에서는 삽입될 위치인 큐의 마지막 부분을 저장하는 변수 rear와 큐의 처음 부분을 저장하는 변수 front가 필요합니다. 또한 큐의 데이터 개수를 저장하는 변수 size를 이용하여 큐의 크기(큐에 들어있는 요소의 수)를 빠르게 알 수 있습니다. 또한 큐의 크기가 0일 경우 큐가 비어 있는 것이므로 비어 있는지 여부도 쉽게 알 수 있습니다. 따라서 배열로 구현하기 위해서는 값들을 담을 배열과 큐의 처음 위치와 마지막 위치(삽입될 위치)를 저장하는 변수가 필요합니다. 또한 enqueue과정과 dequeue과정에서 각각 rear index, front index가 점점 뒤로 밀려나기 때문에 이를 효율적으로 구성하려면 환형 배열로 구현해주어야 합니다. 2) 링크드 리스트를 이용한 방법에서는 값과 다음 노드의 위치를 저장하는 큐 노드들을 이용할 것이며 마지막으로 삽입된 노드의 위치를 저장하는 노드형 포인터 rear와 큐의 가장 앞 노드의 위치를 저장하는 노드형 포인터 front, 노드들의 수를 저장하는 변수 size가 필요합니다. front와 rear는 초기화시 처음에 널 값을 넣어주고, enqueue할 경우 이전에 rear의 next는 새로 삽입하는 노드가 되고, 새로 삽입되는 노드가 rear가 됩니다. dequeue할 경우 이전의 Head의 next가 Head가 되고, 이전의 head는 메모리 할당 해제 시킵니다.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://yoursite.com/tags/자료구조/"}]},{"title":"자료구조_List(연결리스트)","slug":"Computer-Science-Data-Structure-20190211-List","date":"2019-02-11T00:36:51.000Z","updated":"2019-02-11T04:14:59.884Z","comments":true,"path":"2019/02/11/Computer-Science-Data-Structure-20190211-List/","link":"","permalink":"http://yoursite.com/2019/02/11/Computer-Science-Data-Structure-20190211-List/","excerpt":"","text":"LIST(연결리스트)연결리스트는 랜덤 접근이 가능한 배열과는 다른 순차적인(sequential) 자료구조입니다.연결리스트는 노드들로 구성되어 있습니다. 노드는 저장할 값과 다음 노드를 가리키는 포인터로 이루어져 있습니다. 연결리스트의 첫 노드인 헤드(Head)로 부터 노드에 다음 노드를 가리키는 포인터를 사용해 리스트를 순회할 수 있게 됩니다. 위와 같은 연결리스트를 Singly Linked List라고 합니다. Singly Linked List의 각 노드에 이전 노드를 가리키는 포인터를 추가하게 되면 양방향으로 순회가 가능한 Doubly Linked List가 되고, 환형 큐(Circular Queue)와 같이 연결리스트의 마지막 노드인 테일(Tail)과 헤드를 이으면 Circular Linked List가 됩니다.이는 문제의 상황에 따라 구현하여 사용하시면 됩니다. 각 노드는 저장할 값과 자신의 앞, 뒤 노드를 가르키는 포인터를 가짐테일의 포인터는 헤드를 가르킴 두 자료구조의 장단점을 나열해보자면, 배열은 인덱스로 인한 무작위 접근이 가능하고, 리스트에 비해 저장공간을 적게 필요로 하지만, 리스트에 비해 자료의 삽입, 삭제가 비효율 적인 부분이 있습니다. 순서를 유지하면서 자료를 삽입 / 삭제하기 위해서는 최악의 경우 모든 데이터를 옮겨주어야 하기 때문입니다. 리스트는 무작위 접근이 불가능하므로 무조건 순차적으로 탐색해야 하며, 노드에 저장할 값과 포인터를 포함하고 있기 때문에 똑같은 크기의 배열에 비해 저장공간을 많이 차지하게 되지만, 자료의 삽입과 삭제가 새로운 노드를 만들어 포인터로 이어주기만 하면 되기 때문에 간편하고 유연하게 동작합니다. – List(연결리스트) 동적배열 Indexing O(N) O(1) Insert / Delete at beginning O(1) O(N) Insert / Delete at end O(1) when last element is known;O(N) when last element is unknown O(1) Insert / Delete in middle search time + O(1) O(N) 리스트와 배열의 시간복잡도 비교,https://en.wikipedia.org/wiki/Linked_list","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://yoursite.com/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://yoursite.com/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://yoursite.com/tags/자료구조/"}]},{"title":"pyhtonPost","slug":"Python-20190211-pyhtonPost","date":"2019-02-10T15:15:05.000Z","updated":"2019-02-10T15:15:19.246Z","comments":true,"path":"2019/02/11/Python-20190211-pyhtonPost/","link":"","permalink":"http://yoursite.com/2019/02/11/Python-20190211-pyhtonPost/","excerpt":"","text":"","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[]},{"title":"Algorithm problem solving List","slug":"Algorithm-20190210-algorithmPost","date":"2019-02-10T14:53:11.000Z","updated":"2019-02-11T08:10:03.860Z","comments":true,"path":"2019/02/10/Algorithm-20190210-algorithmPost/","link":"","permalink":"http://yoursite.com/2019/02/10/Algorithm-20190210-algorithmPost/","excerpt":"","text":"알고리즘 문제 해결 리스트 사이트 업적 Project Euler 40문제 codeground Lv.14 programmers 1193점 Topcoder-Arena Green Baekjoon Online Judge 16문제 해결 그외 자잘하게 푼 사이트는 제외했습니다. Project Euler내가 컴퓨터공학과 1학년을 마치고 군 입대를 하고 어느정도 여유가 생겼을때 부터 시작하게된 알고리즘 사이트입니다. 프로젝트 오일러는 수학적인 문제들을 컴퓨터 프로그래밍으로 해결하는 사이트입니다. 의미있었고, 어려웠던 문제 10개 선정- [10번] Summation of primes 이백만(2,000,000) 이하 소수의 합은 얼마일까 문제이다. 그때 당시 내가 할수 있는 것은 소수판별 식을 세우고 이백만까지 돌리는 것이다. 당시에는 그것이 대단한것이라고 생각해 두근거리면서 기다리니 답이나왔다. 나중에 에라토스테네스의 체를 알게되고 한동안 에라토스테네스의 체에 빠져살면서 소수에 관해서 연구 했습니다. - [19번] Counting Sundays 20세기 (1901년 1월 1일 ~ 2000년 12월 31일) 에서, 매월 1일이 일요일인 경우는 총 몇 번입니까? 군대에서 당직서면서 종이와 펜으로 손코딩으로 풀던문제였다.기준으로 잡는 날짜와 윤년의 경우를 if문 한줄로 표현하려고 끙끙 앓았었다. 당시에는 모든 날짜에 대해서 검사했는데 해당 월이 몇일 까지 있는지 계속 더해서 mod 7 연산으로 쉽게 파악할수 있었습니다. - [24번] Lexicographic permutations 0, 1, 2, 3, 4, 5, 6, 7, 8, 9로 만들 수 있는 사전식 순열에서 1,000,000번째는 무엇입니까? 지금 풀었다면 길어도 30분안에는 풀수있는 문제였지만 당시에는 순열 알고리즘과 사전식 정렬을 할 줄 몰랐지만 나름 규칙을 찾아서 코딩으로 옮겨내서 풀수있었습니다. - [29번] Distinct powers 2 ≤ a ≤ 100 이고 2 ≤ b ≤ 100인 a, b를 가지고 만들 수 있는 ab는 중복을 제외하면 모두 몇 개입니까? - [50번] Consecutive prime sum 1백만 이하에서는 어떤 소수가 가장 길게 연속되는 소수의 합으로 표현될 수 있습니까? - [52번] Permuted multiples 2배, 3배, 4배, 5배, 6배의 결과도 같은 숫자로 이루어지는 가장 작은 수는 무엇입니까? - [67번] Maximum path sum II 삼각형 꼭대기에서 인접한 숫자를 찾아 내려가면서 가장 큰 합이되는 경로는? - [97번] Large non-Mersenne prime 28433×2^7830457+1 이소수의 마지막 10자리는 얼마입니까? - [113번] Non-bouncy numbers 오락가락수가 아닌 수 - [119번] Digit power sum 자릿수 합의 거듭제곱 codeground삼성에서 만든 programmers코딩테스트 운영 Topcoder-Arena생애 첫 알고리즘 대회 참가 Baekjoon Online Judge최대 문제 보유, 문제은행. 알고리즘 문제 해결 능력 테스트에 대해서..어느 순간부터 알고리즘 문제 해결 능력이 지원자들을 평가하는 요소가 되었습니다.객관적이고 순위를 매길 수 있기 때문에 평가에 불만이 없고, 어느 정도 코딩역량을 알아볼수 있다고 생각합니다.내가 처음으로 알고리즘 문제를 접하고 이를 어떤 인터넷 검색도 없이 해결했을 때 성취감은 이로 말할 수 없었고 이를 통해서 좀더 프로그래밍의 세계에 빠져들었던것 같습니다. 하지만 이제는 거의 모든 기업에서 앞서 코딩테스트를 필수화 시켰고, 다수가 코딩테스트에서 높은 점수를 받기위해서 문제푸는 연습을 하며 알고리즘 문제 해결을 즐기지 못하고 있다고 생각도 듭니다.. 지금에는 알고리즘 문제를 인터넷에 검색하면 해당 문제에 대한 해결법을 얻을 수 있게 되었습니다. 마치 답지를 옆에 가져다 두고 학습지를 풀며 문제 유형을 익히는데 집중하던 주입식 교육을 하게될 지도 모릅니다.한문제 한문제 꾸역꾸역 풀어가며, 인터넷에 떠도는 해답지 보다 훨씬 빠르고 효율적인 알고리즘을 만들 수 있다는 것을 우리는 항상 생각해야 될것입니다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"ps","slug":"ps","permalink":"http://yoursite.com/tags/ps/"}]},{"title":"stockPost","slug":"Stock-20190210-stockPost","date":"2019-02-10T13:31:53.000Z","updated":"2019-02-10T14:52:56.947Z","comments":true,"path":"2019/02/10/Stock-20190210-stockPost/","link":"","permalink":"http://yoursite.com/2019/02/10/Stock-20190210-stockPost/","excerpt":"","text":"","categories":[{"name":"Stock","slug":"Stock","permalink":"http://yoursite.com/categories/Stock/"}],"tags":[]},{"title":"dataSciencePost","slug":"Data-Science-20190210-dataSciencePost","date":"2019-02-10T13:30:33.000Z","updated":"2019-02-10T14:52:42.258Z","comments":true,"path":"2019/02/10/Data-Science-20190210-dataSciencePost/","link":"","permalink":"http://yoursite.com/2019/02/10/Data-Science-20190210-dataSciencePost/","excerpt":"","text":"","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://yoursite.com/categories/Data-Science/"}],"tags":[]},{"title":"Hell..","slug":"Blog-20190210-Hell","date":"2019-02-10T12:42:25.000Z","updated":"2019-02-10T14:52:02.691Z","comments":true,"path":"2019/02/10/Blog-20190210-Hell/","link":"","permalink":"http://yoursite.com/2019/02/10/Blog-20190210-Hell/","excerpt":"","text":"ㅎㅇ","categories":[{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/categories/Blog/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-02-09T19:05:45.592Z","updated":"2019-02-09T19:05:45.592Z","comments":true,"path":"2019/02/10/hello-world/","link":"","permalink":"http://yoursite.com/2019/02/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}